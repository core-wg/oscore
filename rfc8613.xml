<?xml version="1.0" encoding="us-ascii"?>  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>  <!-- Originally generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.9 --><!DOCTYPE rfc SYSTEM "rfc2629.dtd" [<!ENTITY RFC2119 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"><!ENTITY RFC4086 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4086.xml"><!ENTITY RFC4648 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4648.xml"><!ENTITY RFC5234 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5234.xml"><!ENTITY RFC6347 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6347.xml"><!ENTITY RFC7049 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7049.xml"><!ENTITY RFC7230 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7230.xml"><!ENTITY RFC7231 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7231.xml"><!ENTITY RFC7252 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7252.xml"><!ENTITY RFC7641 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7641.xml"><!ENTITY RFC7959 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7959.xml"><!ENTITY RFC8075 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8075.xml"><!ENTITY RFC8132 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8132.xml"><!ENTITY RFC8152 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8152.xml"><!ENTITY RFC8174 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"><!ENTITY RFC8288 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8288.xml"><!ENTITY RFC8323 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8323.xml"><!ENTITY RFC8446 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml"><!ENTITY RFC3552 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml"><!ENTITY RFC3986 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3986.xml"><!ENTITY RFC5116 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5116.xml"><!ENTITY RFC5869 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5869.xml"><!ENTITY RFC6690 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6690.xml"><!ENTITY RFC7228 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7228.xml"><!ENTITY RFC7515 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7515.xml"><!ENTITY RFC7967 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7967.xml"><!ENTITY I-D.ietf-ace-oauth-authz SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-ace-oauth-authz.xml"><!ENTITY I-D.ietf-cbor-cddl SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-cbor-cddl.xml"><!ENTITY I-D.bormann-6lo-coap-802-15-ie SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.bormann-6lo-coap-802-15-ie.xml"><!ENTITY I-D.hartke-core-e2e-security-reqs SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.hartke-core-e2e-security-reqs.xml"><!ENTITY I-D.mattsson-core-coap-actuators SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.mattsson-core-coap-actuators.xml"><!ENTITY I-D.ietf-ace-oscore-profile SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-ace-oscore-profile.xml"><!ENTITY I-D.ietf-core-oscore-groupcomm SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-core-oscore-groupcomm.xml"><!ENTITY I-D.ietf-core-echo-request-tag SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-core-echo-request-tag.xml"><!ENTITY I-D.mcgrew-iv-gen SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.mcgrew-iv-gen.xml">]><?rfc toc="yes"?><?rfc sortrefs="yes"?><?rfc symrefs="yes"?><?rfc tocdepth="2"?><?rfc compact="yes"?><?rfc subcompact="no"?><rfc ipr="trust200902" number="8613" submissionType="IETF" category="std" consensus="yes" updates="7252">  <front>    <title abbrev="OSCORE">Object Security for Constrained RESTful Environments (OSCORE)</title>    <author initials="G." surname="Selander" fullname="Goeran Selander">      <organization>Ericsson AB</organization>      <address>        <email>goran.selander@ericsson.com</email>      </address>    </author>    <author initials="J." surname="Mattsson" fullname="John Mattsson">      <organization>Ericsson AB</organization>      <address>        <email>john.mattsson@ericsson.com</email>      </address>    </author>    <author initials="F." surname="Palombini" fullname="Francesca Palombini">      <organization>Ericsson AB</organization>      <address>        <email>francesca.palombini@ericsson.com</email>      </address>    </author>    <author initials="L." surname="Seitz" fullname="Ludwig Seitz">      <organization>RISE</organization>      <address>        <email>ludwig.seitz@ri.se</email>      </address>    </author>    <date year="2019" month="May" />        <workgroup>CoRE Working Group</workgroup>        <abstract><t>This document defines Object Security for Constrained RESTfulEnvironments (OSCORE), a method for application-layer protection ofthe Constrained Application Protocol (CoAP), using CBOR Object Signingand Encryption (COSE). OSCORE provides end-to-end protection betweenendpoints communicating using CoAP or CoAP-mappable HTTP. OSCORE isdesigned for constrained nodes and networks supporting a range ofproxy operations, including translation between different transportprotocols.</t><t>Although an optional functionality of CoAP, OSCORE altersCoAP options processing and IANA registration. Therefore, thisdocument updates RFC 7252.</t>    </abstract>  </front>  <middle><section anchor="intro" title="Introduction"><t>The Constrained Application Protocol (CoAP) <xreftarget="RFC7252"/> is a web transfer protocol designed forconstrained nodes and networks <xref target="RFC7228"/>; CoAP may bemapped from HTTP <xref target="RFC8075"/>. CoAP specifies the use ofproxies for scalability and efficiency and references DTLS <xreftarget="RFC6347"/> for security. CoAP-to-CoAP, HTTP-to-CoAP, andCoAP-to-HTTP proxies require DTLS or TLS <xref target="RFC8446"/> tobe terminated at the proxy. Therefore, the proxy not only has access tothe data required for performing the intended proxy functionality, but is also able to eavesdrop on, or manipulate any part of, the messagepayload and metadata in transit between the endpoints. The proxy canalso inject, delete, or reorder packets since they are no longerprotected by (D)TLS.</t><!-- [rfced] For the sake of providing the reader some context on "RESTful", would you like to add a sentence of explanation in the introduction?Perhaps:   OSCORE essentially protects the RESTful interactions: the request method,   the requested resource, the message payload, etc. (see Section 4). (Here,   "RESTful" refers to the Representational State Transfer (REST)   architecture.)[Auth]:Replaced with the following sentence"OSCORE essentiallyprotects the RESTful interactions: the request method, the requestedresource, the message payload, etc. (see <xreftarget="protected-fields"/>), where "RESTful" refers to the Representational State Transfer (REST) Architecture <xref target="REST"/>."And added the [REST] reference.--><t>This document defines the Object Security for Constrained RESTfulEnvironments (OSCORE) security protocol, protecting CoAP andCoAP-mappable HTTP requests and responses end-to-end acrossintermediary nodes such as CoAP forward proxies and cross-protocoltranslators including HTTP-to-CoAP proxies <xreftarget="RFC8075"/>. In addition to the core CoAP features defined in<xref target="RFC7252"/>, OSCORE supports the Observe <xreftarget="RFC7641"/>, Block-wise <xref target="RFC7959"/>, andNo-Response <xref target="RFC7967"/> options, as well as the PATCH andFETCH methods <xref target="RFC8132"/>. An analysis of end-to-endsecurity for CoAP messages through some types of intermediary nodes isperformed in <xref target="CoAP-E2E-Sec"/>. OSCORE essentiallyprotects the RESTful interactions: the request method, the requestedresource, the message payload, etc. (see <xreftarget="protected-fields"/>), where "RESTful" refers to the Representational State Transfer (REST) Architecture <xref target="REST"/>. OSCORE protects neither the CoAPmessaging layer nor the CoAP Token, which may change between theendpoints; therefore, those are processed as defined in <xreftarget="RFC7252"/>. Additionally, since the message formats for CoAPover unreliable transport <xref target="RFC7252"/> and for CoAP overreliable transport <xref target="RFC8323"/> differ only in terms ofCoAP messaging layer, OSCORE can be applied to both unreliable andreliable transports (see <xref target="fig-stack"/>).</t><t>OSCORE works in very constrained nodes and networks, thanks to its small message size and the restricted code and memory requirements in addition to what is required by CoAP. Examples of the use of OSCORE are given in <xref target="examples"/>. OSCORE may be used over any underlying layer, such as UDP or TCP, and with non-IP transports (e.g., <xref target="CoAP-802.15.4"/>). OSCORE may also be used in different ways with HTTP. OSCORE messages may be transported in HTTP, and OSCORE may also be used to protect CoAP-mappable HTTP messages, as described below.</t><figure title="Abstract Layering of CoAP with OSCORE" anchor="fig-stack"><artwork align="center"><![CDATA[+-----------------------------------+|            Application            |+-----------------------------------++-----------------------------------+  \|  Requests / Responses / Signaling |  ||-----------------------------------|  ||               OSCORE              |  | CoAP|-----------------------------------|  || Messaging Layer / Message Framing |  |+-----------------------------------+  /+-----------------------------------+|          UDP / TCP / ...          |+-----------------------------------+  ]]></artwork></figure><t>OSCORE is designed to protect as much information as possible whilestill allowing CoAP proxy operations (<xreftarget="coap-coap-proxy"/>). It works with existing CoAP-to-CoAPforward proxies <xref target="RFC7252"/>, but an OSCORE-aware proxywill be more efficient. HTTP-to-CoAP proxies <xref target="RFC8075"/>and CoAP-to-HTTP proxies can also be used with OSCORE, as specified in<xref target="http-op"/>. OSCORE may be used together with TLS or DTLSover one or more hops in the end-to-end path, e.g., transported withHTTPS in one hop and with plain CoAP in another hop. The use of OSCOREdoes not affect the URI scheme; therefore, OSCORE can be used with anyURI scheme defined for CoAP or HTTP. The application decides theconditions for which OSCORE is required.</t><t>OSCORE uses pre-shared keys that may have been establishedout-of-band or with a key establishment protocol (see <xreftarget="context-derivation"/>). The technical solution builds on CBORObject Signing and Encryption (COSE) <xref target="RFC8152"/>,providing end-to-end encryption, integrity, replay protection, andbinding of response to request. A compressed version of COSE is used,as specified in <xref target="compression"/>. The use of OSCORE issignaled in CoAP with a new option (<xref target="option"/>), and inHTTP with a new header field (<xref target="header-field"/>) andcontent type (<xref target="oscore-media-type"/>). The solutiontransforms a CoAP/HTTP message into an "OSCORE message" beforesending, and vice versa after receiving. The OSCORE message is aCoAP/HTTP message related to the original message in the followingway: the original CoAP/HTTP message is translated to CoAP (if notalready in CoAP) and protected in a COSE object. The encrypted messagefields of this COSE object are transported in the CoAP payload/HTTPbody of the OSCORE message, and the OSCORE option/header field isincluded in the message. A sketch of an exchange of OSCORE messages,in the case of the original message being CoAP, is provided in <xreftarget="fig-sketch"/>. The use of OSCORE with HTTP is detailed in<xref target="http-op"/>.</t><figure title="Sketch of CoAP with OSCORE" anchor="fig-sketch"><artwork align="center"><![CDATA[Client                                          Server   |      OSCORE request - POST example.com:      |   |        Header, Token,                        |   |        Options: OSCORE, ...,                 |   |        Payload: COSE ciphertext              |   +--------------------------------------------->|   |                                              |   |<---------------------------------------------+   |      OSCORE response - 2.04 (Changed):       |   |        Header, Token,                        |   |        Options: OSCORE, ...,                 |   |        Payload: COSE ciphertext              |   |                                              |]]></artwork></figure><t>An implementation supporting this specification MAY implement only the client part, MAY implement only the server part, or MAY implement only one of the proxy parts.</t><section anchor="terminology" title="Terminology"><t>    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL    NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",    "MAY", and "OPTIONAL" in this document are to be interpreted as    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/>     when, and only when, they appear in all capitals, as shown here.        </t><t>Readers are expected to be familiar with the terms and concepts described in CoAP <xref target="RFC7252"/>, Observe <xref target="RFC7641"/>, Block-wise  <xref target="RFC7959"/>, COSE <xref target="RFC8152"/>, Concise Binary Object Representation (CBOR) <xref target="RFC7049"/>, Concise Data Definition Language (CDDL) <xref target="CDDL"/> as summarized in <xref target="cddl-sum"/>, and constrained environments <xref target="RFC7228"/>.</t><t>The term "hop" is used to denote a particular leg in the end-to-end path. The concept "hop-by-hop" (as in "hop-by-hop encryption" or "hop-by-hop fragmentation") opposed to "end-to-end", is used in this document to indicate that the messages are processed accordingly in the intermediaries, rather than just forwarded to the next node.</t><t>The term "stop processing" is used throughout the document to denote that the message is not passed up to the CoAP request/response layer (see <xref target="fig-stack"/>).</t><!--[rfced] Will the reader understand this use of punctuation?  Perhaps clarifying this text would be useful. Original:   The terms Common/Sender/Recipient Context, Master Secret/Salt, Sender   ID/Key, Recipient ID/Key, ID Context, and Common IV are defined in   Section 3.1.[Auth]:Replaced with:   The terms Common Context, Sender Context, Recipient Context, Master   Secret, Master Salt, Sender ID, Sender Key, Recipient ID, Recipient   Key, ID Context, and Common IV are defined in Section 3.1.--><t>The terms Common Context, Sender Context, Recipient Context, Master Secret, Master Salt, Sender ID, Sender Key, Recipient ID, Recipient Key, ID Context, and Common IV are defined in <xref target="context-definition"/>.</t></section></section><section anchor="option" title="The OSCORE Option"><t>The OSCORE option defined in this section (see <xref target="fig-option"/>, which extends &quot;Table 4: Options&quot; of <xref target="RFC7252"/>) indicates that the CoAP message is an OSCORE message and that it contains a compressed COSE object (see Sections <xref target="cose-object" format="counter"/> and <xref target="compression" format="counter"/>). The OSCORE option is critical, safe to forward, part of the cache key, and not repeatable.</t><figure title="The OSCORE Option" anchor="fig-option"><artwork align="center"><![CDATA[+------+---+---+---+---+----------------+--------+--------+---------+| No.  | C | U | N | R | Name           | Format | Length | Default |+------+---+---+---+---+----------------+--------+--------+---------+|   9  | x |   |   |   | OSCORE         |  (*)   | 0-255  | (none)  |+------+---+---+---+---+----------------+--------+--------+---------+    C = Critical,   U = Unsafe,   N = NoCacheKey,   R = Repeatable       (*) See below.]]></artwork></figure><t>The OSCORE option includes the OSCORE flag bits (<xreftarget="compression"/>), the Sender Sequence Number, the Sender ID,and the ID Context when these fields are present (<xreftarget="context"/>). The detailed format and length is specified in<xref target="compression"/>. If the OSCORE flag bits are all zero(0x00), the Option value SHALL be empty (Option Length = 0). Anendpoint receiving a CoAP message without payload that also containsan OSCORE option SHALL treat it as malformed and reject it.</t><t>A successful response to a request with the OSCORE option SHALLcontain the OSCORE option. Whether error responses contain the OSCOREoption depends on the error type (see <xreftarget="processing"/>).</t><t>For CoAP proxy operations, see <xreftarget="coap-coap-proxy"/>.</t></section><section anchor="context" title="The Security Context"><t>OSCORE requires that client and server establish a shared security context used to process the COSE objects. OSCORE uses COSE with an Authenticated Encryption with Associated Data (AEAD, <xref target="RFC5116"/>) algorithm for protecting message data between a client and a server. In this section, we define the security context and how it is derived in client and server based on a shared secret and a key derivation function.</t><section anchor="context-definition" title="Security Context Definition"><t>The security context is the set of information elements necessary to carry out the cryptographic operations in OSCORE. For each endpoint, the security context is composed of a "Common Context", a "Sender Context", and a "Recipient Context".</t><t>The endpoints protect messages to send using the Sender Context and verify messages received using the Recipient Context; both contexts being derived from the Common Context and other data. Clients and servers need to be able to retrieve the correct security context to use.</t><t>An endpoint uses its Sender ID (SID) to derive its Sender Context; the other endpoint uses the same ID, now called Recipient ID (RID), to derive its Recipient Context. In communication between two endpoints, the Sender Context of one endpoint matches the Recipient Context of the other endpoint, and vice versa. Thus, the two security contexts identified by the same IDs in the two endpoints are not the same, but they are partly mirrored. Retrieval and use of the security context are shown in <xref target="fig-context"/>.</t><figure title="Retrieval and Use of the Security Context" anchor="fig-context"><artwork align="center"><![CDATA[          .-----------------------------------------------.          |                Common Context                 |          +---------------------.---.---------------------+                  |    Sender Context   | = |  Recipient Context  |          +---------------------+   +---------------------+           |  Recipient Context  | = |    Sender Context   |          '---------------------'   '---------------------'                   Client                   Server                      |                       |Retrieve context for  | OSCORE request:       | target resource      |   Token = Token1,     |Protect request with  |   kid = SID, ...      |  Sender Context      +---------------------->| Retrieve context with                      |                       |  RID = kid                      |                       | Verify request with                      |                       |  Recipient Context                      | OSCORE response:      | Protect response with                      |   Token = Token1, ... |  Sender ContextRetrieve context with |<----------------------+ Token = Token1       |                       |Verify request with   |                       | Recipient Context    |                       |]]></artwork></figure><t>The Common Context contains the following parameters:</t><t><list style="symbols">  <t>AEAD Algorithm. The COSE AEAD algorithm to use for encryption.</t>  <t>HKDF Algorithm. An HMAC-based key derivation function (HKDF) <xref target="RFC5869"/> used to derive the Sender Key, Recipient Key, and Common IV.</t>  <t>Master Secret. Variable length, random byte string (see <xref target="master-secret"/>) used to derive AEAD keys and Common IV.</t>  <t>Master Salt. Optional variable-length byte string containing the salt used to derive AEAD keys and Common IV.</t>  <t>ID Context. Optional variable-length byte string providing additional information to identify the Common Context and to derive AEAD keys and Common IV. The use of ID Context is described in <xref target="context-hint"/>.</t>  <t>Common IV. Byte string derived from the Master Secret, Master Salt, and ID Context. Used to generate the AEAD nonce (see <xref target="nonce"/>). Same length as the nonce of the AEAD Algorithm.</t></list></t><t>The Sender Context contains the following parameters:</t><t><list style="symbols">  <t>Sender ID. Byte string used to identify the Sender Context, to derive AEAD keys and Common IV, and to ensure unique AEAD nonces. Maximum length is determined by the AEAD Algorithm.</t>  <t>Sender Key. Byte string containing the symmetric AEAD key to protect messages to send. Derived from Common Context and Sender ID. Length is determined by the AEAD Algorithm.</t>  <t>Sender Sequence Number. Non-negative integer used by the sender to enumerate requests and certain responses, e.g., Observe notifications. Used as "Partial IV" <xref target="RFC8152"/> to generate unique AEAD nonces. Maximum value is determined by the AEAD Algorithm. Initialization is described in <xref target="initial-replay"/>.</t></list></t><t>The Recipient Context contains the following parameters:</t><t><list style="symbols">  <t>Recipient ID. Byte string used to identify the Recipient Context, to derive AEAD keys and Common IV, and to ensure unique AEAD nonces. Maximum length is determined by the AEAD Algorithm.</t>  <t>Recipient Key. Byte string containing the symmetric AEAD key to verify messages received. Derived from Common Context and Recipient ID. Length is determined by the AEAD Algorithm.</t>  <t>Replay Window (Server only). The replay window used to verify requests received. Replay protection is described in <xref target="replay-protection"/> and <xref target="initial-replay"/>.</t></list></t><t>All parameters except Sender Sequence Number and Replay Window are immutable once the security context is established. An endpoint may free up memory by not storing the Common IV, Sender Key, and Recipient Key, deriving them when needed. Alternatively, an endpoint may free up memory by not storing the Master Secret and Master Salt after the other parameters have been derived.</t><t>Endpoints MAY operate as both client and server and use the same security context for those roles. Independent of being client or server, the endpoint protects messages to send using its Sender Context, and verifies messages received using its Recipient Context. The endpoints MUST NOT change the Sender/Recipient ID when changing roles. In other words, changing the roles does not change the set of AEAD keys to be used.</t></section><section anchor="context-derivation" title="Establishment of Security Context Parameters"><t>Each endpoint derives the parameters in the security context from a small set of input parameters. The following input parameters SHALL be preestablished:</t><t><list style="symbols">  <t>Master Secret</t>  <t>Sender ID</t>  <t>Recipient ID</t></list></t><t>The following input parameters MAY be preestablished. In case any of these parameters is not preestablished, the default value indicated below is used:</t><t><list style="symbols">  <t>AEAD Algorithm  <list style="symbols">      <t>Default is AES-CCM-16-64-128 (COSE algorithm encoding: 10)</t>    </list></t>  <t>Master Salt  <list style="symbols">      <t>Default is the empty byte string</t>    </list></t>  <t>HKDF Algorithm  <list style="symbols">      <t>Default is HKDF SHA-256</t>    </list></t>  <t>Replay Window  <list style="symbols">  <t>The default mechanism is an anti-replay sliding window (see Section 4.1.2.6 of <xref target="RFC6347"/> with a window size of 32 </t><!--[rfced] Should some units of measure be added here or will this beclear to the reader?  Please review similar text throughout (forexample, last sentence of Section 3.2.2) and let us know ifupdates are necessary.Original:      *  Default is DTLS-type replay protection with a window size of 32         [RFC6347][Auth] This will be clear to the reader. We have reviewed the text and implemented the following changes for clarity and consistency withRFC6347:OLD   o  Replay Window (Server only).  The replay window to verify requests      received.  Replay protection is described in Section 7.4 and      Section 3.2.2.NEW   o  Replay Window (Server only).  The replay window used to verify requests      received.  Replay protection is described in Section 7.4 and      Section 3.2.2.        OLD   o  Replay Window      *  Default is DTLS-type replay protection with a window size of 32         [RFC6347]NEW   o  Replay Window      *  The default mechanism is an anti-replay sliding window (see Section          4.1.2.6 of [RFC6347]) with a window size of 32        OLD   The supported types of replay protection and replay window length is   application specific and depends on how OSCORE is transported (see   Section 7.4).  The default is DTLS-type replay protection with a   window size of 32 initiated as described in Section 4.1.2.6 of   [RFC6347].NEW   The supported types of replay protection and replay window size is   application specific and depends on how OSCORE is transported (see   Section 7.4).  The default mechanism is the anti-replay window of    received messages used by IPsec AH/ESP and DTLS (see Section 4.1.2.6 of   [RFC6347]) with a window size of 32.-->    </list></t></list></t><t>All input parameters need to be known and agreed on by both endpoints, but the Replay Window may be different in the two endpoints. The way the input parameters are preestablished is application specific. Considerations of security context establishment are given in <xref target="sec-context-establish"/> and examples of deploying OSCORE in <xref target="deployment-examples"/>.</t><section anchor="derivation-of-sender-key-recipient-key-and-common-iv" title="Derivation of Sender Key, Recipient Key, and Common IV"><t>The HKDF MUST be one of the HMAC-based HKDF <xref target="RFC5869"/> algorithms defined for COSE <xref target="RFC8152"/>. HKDF SHA-256 is mandatory to implement. The security context parameters Sender Key, Recipient Key, and Common IV SHALL be derived from the input parameters using the HKDF, which consists of the composition of the HKDF-Extract and HKDF-Expand steps <xref target="RFC5869"/>:</t><figure><artwork><![CDATA[   output parameter = HKDF(salt, IKM, info, L) ]]></artwork></figure><t>where:</t><t><list style="symbols">  <t>salt is the Master Salt as defined above</t>  <t>IKM is the Master Secret as defined above</t>  <t>info is the serialization of a CBOR array consisting of (the notation follows <xref target="cddl-sum"/>):</t></list></t><figure><artwork type="CDDL"><![CDATA[   info = [     id : bstr,     id_context : bstr / nil,     alg_aead : int / tstr,     type : tstr,     L : uint,   ]]]></artwork></figure><t>where:</t><t><list style="symbols">  <t>id is the Sender ID or Recipient ID when deriving Sender Key and Recipient Key, respectively, and the empty byte string when deriving the Common IV.</t>  <t>id_context is the ID Context, or nil if ID Context is not provided.</t>  <t>alg_aead is the AEAD Algorithm, encoded as defined in <xref target="RFC8152"/>.</t>  <t>type is "Key" or "IV". The label is an ASCII string and does not include a trailing NUL byte.</t>  <t>L is the size of the key/nonce for the AEAD Algorithm used, in bytes.</t></list></t><t>For example, if the algorithm AES-CCM-16-64-128 (see Section 10.2 in <xref target="RFC8152"/>) is used, the integer value for alg_aead is 10, the value for L is 16 for keys and 13 for the Common IV. Assuming use of the default algorithms HKDF SHA-256 and AES-CCM-16-64-128, the extract phase of HKDF produces a pseudorandom key (PRK) as follows:</t><figure><artwork><![CDATA[   PRK = HMAC-SHA-256(Master Salt, Master Secret)]]></artwork></figure><t>and as L is smaller than the hash function output size, the expand phase of HKDF consists of a single HMAC invocation; therefore, the Sender Key, Recipient Key, and Common IV are the first 16 or 13 bytes of</t><figure><artwork><![CDATA[   output parameter = HMAC-SHA-256(PRK, info || 0x01)]]></artwork></figure><!--[rfced] May we update the use of "info" below as suggested forsubject/verb agreement purposes?Original:   where different info are used for each derived parameter and where ||   denotes byte string concatenation.   Perhaps A:   where different infos are used for each derived parameter and where ||   denotes byte string concatenation.Perhaps B:   where different info values are used for each derived parameter and where ||   denotes byte string concatenation.[Auth]: Replaced with   where different values of info are used for each derived parameter   and where || denotes byte string concatenation.We want to keep "info" singular, since we are referring to the name of the parameter that is mentioned just above, used as input of the HMAC-SHA-256 function.--><t>where different values of info are used for each derived parameter and where || denotes byte string concatenation.</t><t>Note that <xref target="RFC5869"/> specifies that if the salt is not provided, it is set to a string of zeros. For implementation purposes, not providing the salt is the same as setting the salt to the empty byte string. OSCORE sets the salt default value to empty byte string, which is converted to a string of zeroes (see Section 2.2 of <xref target="RFC5869"/>).</t></section><section anchor="initial-replay" title="Initial Sequence Numbers and Replay Window"><t>The Sender Sequence Number is initialized to 0.</t><t>The supported types of replay protection and replay window size is application specific and depends on how OSCORE is transported (see <xref target="replay-protection"/>). The default mechanism is the anti-replay window of received messages used by IPsec AH/ESP and DTLS (see Section 4.1.2.6 of <xref target="RFC6347"/>) with a window size of 32.</t></section></section><section anchor="req-params" title="Requirements on the Security Context Parameters"><t>To ensure unique Sender Keys, the quartet (Master Secret, Master Salt, ID Context, Sender ID) MUST be unique, i.e., the pair (ID Context, Sender ID) SHALL be unique in the set of all security contexts using the same Master Secret and Master Salt. This means that Sender ID SHALL be unique in the set of all security contexts using the same Master Secret, Master Salt, and ID Context; such a requirement guarantees unique (key, nonce) pairs for the AEAD.</t><t>Different methods can be used to assign Sender IDs: a protocol that allows the parties to negotiate locally unique identifiers, a trusted third party (e.g., <xref target="ACE-OAuth"/>), or the identifiers can be assigned out-of-band. The Sender IDs can be very short (note that the empty string is a legitimate value). The maximum length of Sender ID in bytes equals the length of the AEAD nonce minus 6, see <xref target="nonce"/>. For AES-CCM-16-64-128 the maximum length of Sender ID is 7 bytes.</t><t>To simplify retrieval of the right Recipient Context, the Recipient ID SHOULD be unique in the sets of all Recipient Contexts used by an endpoint. If an endpoint has the same Recipient ID with different Recipient Contexts, i.e., the Recipient Contexts are derived from different Common Contexts, then the endpoint may need to try multiple times before verifying the right security context associated to the Recipient ID.</t><t>The ID Context is used to distinguish between security contexts. The methods used for assigning Sender ID can also be used for assigning the ID Context. Additionally, the ID Context can be used to introduce randomness into new Sender and Recipient Contexts (see <xref target="master-secret-multiple"/>). ID Context can be arbitrarily long.</t></section></section><section anchor="protected-fields" title="Protected Message Fields"><t>OSCORE transforms a CoAP message (which may have been generated from an HTTP message) into an OSCORE message, and vice versa. OSCORE protects as much of the original message as possible while still allowing certain proxy operations (see Sections <xref target="coap-coap-proxy" format="counter"/> and <xref target="http-op" format="counter"/>). This section defines how OSCORE protects the message fields and transfers them end-to-end between client and server (in any direction).</t><t>The remainder of this section and later sections focus on the behavior in terms of CoAP messages. If HTTP is used for a particular hop in the end-to-end path, then this section applies to the conceptual CoAP message that is mappable to/from the original HTTP message as discussed in <xref target="http-op"/>.  That is, an HTTP message is conceptually transformed to a CoAP message and then to an OSCORE message, and similarly in the reverse direction.  An actual implementation might translate directly from HTTP to OSCORE without the intervening CoAP representation.</t><t>Protection of Signaling messages (Section 5 of <xref target="RFC8323"/>) is specified in <xref target="coap-signaling"/>. The other parts of this section target request/response messages.</t><t>Message fields of the CoAP message may be protected end-to-end between CoAP client and CoAP server in different ways:</t><t><list style="symbols">  <t>Class E: encrypted and integrity protected,</t>  <t>Class I: integrity protected only, or</t>  <t>Class U: unprotected.</t></list></t><t>The sending endpoint SHALL transfer Class E message fields in the ciphertext of the COSE object in the OSCORE message. The sending endpoint SHALL include Class I message fields in the AAD of the AEAD algorithm, allowing the receiving endpoint to detect if the value has changed in transfer. Class U message fields SHALL NOT be protected in transfer. Class I and Class U message field values are transferred in the header or options part of the OSCORE message, which is visible to proxies.</t><t>Message fields not visible to proxies, i.e., transported in the ciphertext of the COSE object, are called "Inner" (Class E). Message fields transferred in the header or options part of the OSCORE message, which is visible to proxies, are called "Outer" (Class I or Class U). There are currently no Class I options defined.</t><t>An OSCORE message may contain both an Inner and an Outer instance of a certain CoAP message field. Inner message fields are intended for the receiving endpoint, whereas Outer message fields are used to enable proxy operations.</t><section anchor="coap-options" title="CoAP Options"><t>A summary of how options are protected is shown in <xref target="fig-option-protection"/>. Note that some options may have both Inner and Outer message fields, which are protected accordingly. Certain options require special processing as is described in <xref target="special-options"/>.</t><t>Options that are unknown or for which OSCORE processing is not defined SHALL be processed as Class E (and no special processing). Specifications of new CoAP options SHOULD define how they are processed with OSCORE. A new COAP option SHOULD be of Class E unless it requires proxy processing. If a new CoAP option is of class U, the potential issues withthe option being unprotected SHOULD be documented (see <xref target="unprot-fields"/>).</t><section anchor="inner-options" title="Inner Options"><t>Inner option message fields (Class E) are used to communicate directly withthe other endpoint.</t><t>The sending endpoint SHALL write the Inner option message fields present in the original CoAP message into the plaintext of the COSE object (<xref target="plaintext"/>) and then remove the Inner option message fields from the OSCORE message.</t><t>The processing of Inner option message fields by the receiving endpoint is specified in Sections <xref target="ver-req" format="counter"/> and <xref target="ver-res" format="counter"/>.</t><figure title="Protection of CoAP Options" anchor="fig-option-protection"><artwork align="center"><![CDATA[  +------+-----------------+---+---+  | No.  | Name            | E | U |  +------+-----------------+---+---+  |   1  | If-Match        | x |   |  |   3  | Uri-Host        |   | x |  |   4  | ETag            | x |   |  |   5  | If-None-Match   | x |   |  |   6  | Observe         | x | x |  |   7  | Uri-Port        |   | x |  |   8  | Location-Path   | x |   |  |   9  | OSCORE          |   | x |  |  11  | Uri-Path        | x |   |  |  12  | Content-Format  | x |   |  |  14  | Max-Age         | x | x |  |  15  | Uri-Query       | x |   |  |  17  | Accept          | x |   |  |  20  | Location-Query  | x |   |  |  23  | Block2          | x | x |  |  27  | Block1          | x | x |  |  28  | Size2           | x | x |  |  35  | Proxy-Uri       |   | x |  |  39  | Proxy-Scheme    |   | x |  |  60  | Size1           | x | x |  | 258  | No-Response     | x | x |  +------+-----------------+---+---+E = Encrypt and Integrity Protect (Inner)U = Unprotected (Outer)]]></artwork></figure></section><section anchor="outer-options" title="Outer Options"><t>Outer option message fields (Class U or I) are used to support proxy operations, see <xref target="supp-proxy-op"/>.</t><t>The sending endpoint SHALL include the Outer option message field present in the original message in the options part of the OSCORE message. All Outer option message fields, including the OSCORE option, SHALL be encoded as described in Section 3.1 of <xref target="RFC7252"/>, where the delta is the difference from the previously included instance of Outer option message field.</t><t>The processing of Outer options by the receiving endpoint is specified in Sections <xref target="ver-req" format="counter"/> and <xref target="ver-res" format="counter"/>.</t><t>A procedure for integrity-protection-only of Class I option message fields is specified in <xref target="AAD"/>. Specifications that introduce repeatable Class I options MUST specify that proxies MUST NOT change the order of the instances of such an option in the CoAP message.</t><t>Note: There are currently no Class I option message fields defined.</t></section><section anchor="special-options" title="Special Options"><t>Some options require special processing as specified in this section.</t><section anchor="max-age" title="Max-Age"><t>An Inner Max-Age message field is used to indicate the maximum time a response may be cached by the client (as defined in <xref target="RFC7252"/>), end-to-end from the server to the client, taking into account that the option is not accessible to proxies. The Inner Max-Age SHALL be processed by OSCORE as a normal Inner option, specified in <xref target="inner-options"/>.</t><t>An Outer Max-Age message field is used to avoid unnecessary caching of error responses  caused by OSCORE processing at OSCORE-unaware intermediary nodes. A server MAY set a Class U Max-Age message field with value zero to such error responses, described in Sections <xref target="replay-protection" format="counter"/>, <xref target="ver-req" format="counter"/>, and <xref target="ver-res" format="counter"/>, since these error responses are cacheable, but subsequent OSCORE requests would never create a hit in the intermediary caching it. Setting the Outer Max-Age to zero relieves the intermediary from uselessly caching responses. Successful OSCORE responses do not need to include an Outer Max-Age option since the responses appear to the OSCORE-unaware intermediary as 2.04 (Changed) responses, which are non-cacheable (see <xref target="coap-header"/>).</t><t>The Outer Max-Age message field is processed according to <xref target="outer-options"/>.</t></section><section anchor="uri-host" title="Uri-Host and Uri-Port"><t>When the Uri-Host and Uri-Port are set to their default values (see Section 5.10.1 <xref target="RFC7252"/>), they are omitted from the message (Section 5.4.4 of <xref target="RFC7252"/>), which is favorable both for overhead and privacy.</t><t>In order to support forward proxy operations, Proxy-Scheme, Uri-Host, and Uri-Port need to be Class U. For the use of Proxy-Uri, see <xref target="proxy-uri"/>.</t><t>Manipulation of unprotected message fields (including Uri-Host, Uri-Port, destination IP/port or request scheme) MUST NOT lead to an OSCORE message becoming verified by an unintended server. Different servers SHALL have different security contexts.</t></section><section anchor="proxy-uri" title="Proxy-Uri"><t>When Proxy-Uri is present, the client SHALL first decompose the Proxy-Uri value of the original CoAP message into the Proxy-Scheme, Uri-Host, Uri-Port, Uri-Path, and Uri-Query options according to Section 6.4 of <xref target="RFC7252"/>.</t><t>Uri-Path and Uri-Query are Class E options and SHALL be protected and processed as Inner options (<xref target="inner-options"/>).</t><t>The Proxy-Uri option of the OSCORE message SHALL be set to the composition of Proxy-Scheme, Uri-Host, and Uri-Port options as specified in Section 6.5 of <xref target="RFC7252"/> and processed as an Outer option of Class U (<xref target="outer-options"/>).</t><t>Note that replacing the Proxy-Uri value with the Proxy-Scheme and Uri-* options works by design for all CoAP URIs (see Section 6 of <xref target="RFC7252"/>). OSCORE-aware HTTP servers should not use the userinfo component of the HTTP URI (as defined in Section 3.2.1 of <xref target="RFC3986"/>), so that this type of replacement is possible in the presence of CoAP-to-HTTP proxies (see <xref target="coap2http"/>). In future specifications of cross-protocol proxying behavior using different URI structures, it is expected that the authors will create Uri-* options that allow decomposing the Proxy-Uri, and specifying the OSCORE processing.</t><t>An example of how Proxy-Uri is processed is given here. Assume that the original CoAP message contains:</t><t><list style="symbols">  <t>Proxy-Uri = "coap://example.com/resource?q=1"</t></list></t><t>During OSCORE processing, Proxy-Uri is split into:</t><t><list style="symbols">  <t>Proxy-Scheme = "coap"</t>  <t>Uri-Host = "example.com"</t>  <t>Uri-Port = "5683"</t>  <t>Uri-Path = "resource"</t>  <t>Uri-Query = "q=1"</t></list></t><t>Uri-Path and Uri-Query follow the processing defined in <xref target="inner-options"/>; thus, they are encrypted and transported in the COSE object:</t><t><list style="symbols">  <t>Uri-Path = "resource"</t>  <t>Uri-Query = "q=1"</t></list></t><t>The remaining options are composed into the Proxy-Uri included in the options part of the OSCORE message, which has value:</t><t><list style="symbols">  <t>Proxy-Uri = "coap://example.com"</t></list></t><t>See Sections 6.1 and 12.6 of <xref target="RFC7252"/> for more details.</t></section><section anchor="block-options" title="The Block Options"><t>Block-wise <xref target="RFC7959"/> is an optional feature. An implementation MAY support CoAP <xref target="RFC7252"/> and the OSCORE option without supporting block-wise transfers. The Block options (Block1, Block2, Size1, Size2), when Inner message fields, provide secure message segmentation such that each segment can be verified. The Block options, when Outer message fields, enable hop-by-hop fragmentation of the OSCORE message. Inner and Outer block processing may have different performance properties depending on the underlying transport. The end-to-end integrity of the message can be verified both in case of Inner and Outer Block-wise transfers, provided all blocks are received.</t><section anchor="inner-block-options" title="Inner Block Options"><t>The sending CoAP endpoint MAY fragment a CoAP message as defined in <xref target="RFC7959"/> before the message is processed by OSCORE. In this case, the Block options SHALL be processed by OSCORE as normal Inner options (<xref target="inner-options"/>). The receiving CoAP endpoint SHALL process the OSCORE message before processing Block-wise as defined in <xref target="RFC7959"/>.</t></section><section anchor="outer-block-options" title="Outer Block Options"> <t>Proxies MAY fragment an OSCORE message using <xreftarget="RFC7959"/> by introducing Block option message fields that areOuter (<xref target="outer-options"/>). Note that the Outer Blockoptions are neither encrypted nor integrity protected. As aconsequence, a proxy can maliciously inject block fragmentsindefinitely, since the receiving endpoint needs to receive the lastblock (see <xref target="RFC7959"/>) to be able to compose the OSCOREmessage and verify its integrity. Therefore, applications supportingOSCORE and <xref target="RFC7959"/> MUST specify a security policydefining a maximum unfragmented message size (MAX_UNFRAGMENTED_SIZE)considering the maximum size of message that can be handled by theendpoints. Messages exceeding this size SHOULD be fragmented by thesending endpoint using Inner Block options (<xreftarget="inner-block-options"/>).</t><t>An endpoint receiving an OSCORE message with an Outer Block option SHALL first process this option according to <xref target="RFC7959"/>, until all blocks of the OSCORE message have been received or the cumulated message size of the blocks exceeds MAX_UNFRAGMENTED_SIZE.  In the former case, the processing of the OSCORE message continues as defined in this document. In the latter case, the message SHALL be discarded.</t><t>Because of encryption of Uri-Path and Uri-Query, messages to the same server may, from the point of view of a proxy, look like they also target the same resource. A proxy SHOULD mitigate a potential mix-up of blocks from concurrent requests to the same server, for example, using the Request-Tag processing specified in Section 3.3.2 of <xref target="CoAP-ECHO-REQ-TAG"/>.</t></section></section><section anchor="observe" title="Observe"><t>Observe <xref target="RFC7641"/> is an optional feature. An implementation MAY support CoAP <xref target="RFC7252"/> and the OSCORE option without supporting <xref target="RFC7641"/>, in which case the Observe-related processing can be omitted.</t><t>The support for Observe <xref target="RFC7641"/> with OSCORE targets the requirements on forwarding of Section 2.2.1 of <xref target="CoAP-E2E-Sec"/>, i.e., that observations go through intermediary nodes, as illustrated in Figure 8 of <xref target="RFC7641"/>.</t><t>Inner Observe SHALL be used to protect the value of the Observe option between the endpoints. Outer Observe SHALL be used to support forwarding by intermediary nodes.</t><t>The server SHALL include a new Partial IV (see <xref target="cose-object"/>) in responses (with or without the Observe option) to Observe registrations, except for the first response where Partial IV MAY be omitted.</t><t>For cancellations, Section 3.6 of <xref target="RFC7641"/> specifies that all options MUST be identical to those in the registration request except for the Observe option and the set of ETag options. For OSCORE messages, this matching is to be done to the options in the decrypted message.</t><t><xref target="RFC7252"/> does not specify how the server should act upon receiving the same Token in different requests. When using OSCORE, the server SHOULD NOT remove an active observation just because it receives a request with the same Token.</t><t>Since POST with the Observe option is not defined, for messages with Observe option, the Outer Code MUST be set to 0.05 (FETCH) for requests and to 2.05 (Content) for responses (see <xref target="coap-header"/>).</t><section anchor="observe-registration" title="Registrations and Cancellations"><t>The Inner and Outer Observe options in the request MUST contain the Observe value of the original CoAP request; 0 (registration) or 1 (cancellation).</t><t>Every time a client issues a new request with the Observe option, a new Partial IV MUST be used (see <xref target="cose-object"/>), and so the payload and OSCORE option are changed. The server uses the Partial IV of the new request as the 'request_piv' of all associated notifications (see <xref target="AAD"/>).</t><!--[rfced] Please clarify "which verify [...] as coming from the other endpoint". Perhaps the intended meaning is "that are verified [...] as having come from the other endpoint"?Original:   Intermediaries are not assumed to have access to the OSCORE security   context used by the endpoints, and thus cannot make requests or   transform responses with the OSCORE option which verify at the   receiving endpoint as coming from the other endpoint.Perhaps:   Intermediaries are not assumed to have access to the OSCORE   security context used by the endpoints; thus, they cannot make   requests or transform responses with the OSCORE option that are   verified (at the receiving endpoint) as having come from the other    endpoint.[Auth] We tried to clarify. Replaced original with:   Intermediaries are not assumed to have access to the OSCORE security   context used by the endpoints; thus, they cannot make requests or   transform responses with the OSCORE option that pass verification (at   the receiving endpoint) as having come from the other endpoint. --><t>Intermediaries are not assumed to have access to the OSCORE security context used by the endpoints; thus, they cannot make requests or transform responses with the OSCORE option that pass verification (at the receiving endpoint) as having come from the other endpoint. This has the following consequences and limitations for Observe operations.</t><t><list style="symbols">  <t>An intermediary node removing the Outer Observe 0 option does not change the registration request to a request without Observe option (see Section 2 of <xref target="RFC7641"/>). Instead other means for cancellation may be used as described in Section 3.6 of <xref target="RFC7641"/>.</t>  <t>An intermediary node is not able to transform a normal response into an OSCORE-protected Observe notification (see Figure 7 of <xref target="RFC7641"/>) that verifies as coming from the server.</t>  <t>An intermediary node is not able to initiate an OSCORE protected  Observe registration (Observe option with value 0) that verifies as coming  from the client. An OSCORE-aware intermediary SHALL NOT initiate  registrations of observations (see <xref  target="coap-coap-proxy"/>). If an OSCORE-unaware proxy resends an  old registration message from a client, the replay  protection mechanism in the server will be triggered. To prevent this from resulting  in the OSCORE-unaware proxy canceling the registration, a server  MAY respond to a replayed registration request with a replay of a  cached notification. Alternatively, the server MAY send a new  notification.</t>  <t>An intermediary node is not able to initiate an OSCORE-protected Observe cancellation (Observe option with value 1) that verifies as coming from the client. An application MAY decide to allow intermediaries to cancel Observe registrations, e.g., to send the Observe option with value 1 (see Section 3.6 of <xref target="RFC7641"/>); however, that can also be done with other methods, e.g., reusing the Token in a different request or sending a RST message. This is out of scope for this specification.</t></list></t></section><section anchor="notifications" title="Notifications"><t>If the server accepts an Observe registration, a Partial IV MUST be included in all notifications (both successful and error), except for the first one where the Partial IV MAY be omitted. To protect against replay, the client SHALL maintain a Notification Number for each Observation it registers. The Notification Number is a non-negative integer containing the largest Partial IV of the received notifications for the associated Observe registration. Further details of replay protection of notifications are specified in <xref target="replay-notifications"/>.</t><t>For notifications, the Inner Observe option value MUST be empty (see Section 3.2 of <xref target="RFC7252"/>). The Outer Observe option in a notification is needed for intermediary nodes to allow multiple responses to one request, and it may be set to the value of the Observe option in the original CoAP message. The client performs ordering of notifications and replay protection by comparing their Partial IVs and SHALL ignore the Outer Observe option value.</t><t>If the client receives a response to an Observe request without an Inner Observe option, then it verifies the response as a non-Observe response, as specified in <xref target="ver-res"/>. If the client receives a response to a non-Observe request with an Inner Observe option, then it stops processing the message, as specified in <xref target="ver-res"/>.</t><t>A client MUST consider the notification with the highest Partial IV as the freshest, regardless of the order of arrival. In order to support existing Observe implementations, the OSCORE client implementation MAY set the Observe option value to the three least significant bytes of the Partial IV. Implementations need to make sure that the notification without Partial IV is considered the oldest.</t></section></section><section anchor="no-resp" title="No-Response"><t>No-Response <xref target="RFC7967"/> is an optional feature used by the client to communicate its disinterest in certain classes of responses to a particular request. An implementation MAY support <xref target="RFC7252"/> and the OSCORE option without supporting <xref target="RFC7967"/>.</t><t>If used, No-Response MUST be Inner. The Inner No-Response SHALL be processed by OSCORE as specified in <xref target="inner-options"/>. The Outer option SHOULD NOT be present. The server SHALL ignore the Outer No-Response option. The client MAY set the Outer No-Response value to 26 (suppress all known codes) if the Inner value is set to 26. The client MUST be prepared to receive and discard 5.04 (Gateway Timeout) error messages from intermediaries potentially resulting from destination time out due to no response.</t></section><section anchor="oscore" title="OSCORE"><t>The OSCORE option is only defined to be present in OSCORE messages as an indication that OSCORE processing has been performed. The content in the OSCORE option is neither encrypted nor integrity protected as a whole, but some part of the content of this option is protected (see <xref target="AAD"/>). Nested use of OSCORE is not supported: If OSCORE processing detects an OSCORE option in the original CoAP message, then processing SHALL be stopped.</t><figure title="Protection of CoAP Header Fields and Payload" anchor="fig-fields-protection"><artwork align="center"><![CDATA[      +------------------+---+---+      | Field            | E | U |      +------------------+---+---+      | Version (UDP)    |   | x |      | Type (UDP)       |   | x |      | Length (TCP)     |   | x |      | Token Length     |   | x |      | Code             | x |   |      | Message ID (UDP) |   | x |      | Token            |   | x |      | Payload          | x |   |      +------------------+---+---+E = Encrypt and Integrity Protect (Inner)U = Unprotected (Outer)]]></artwork></figure></section></section></section><section anchor="coap-header" title="CoAP Header Fields and Payload"><t>A summary of how the CoAP header fields and payload are protected is shown in <xref target="fig-fields-protection"/>, including fields specific to CoAP over UDP and CoAP over TCP (marked accordingly in the table).</t><!--[rfced] May we rephrase the following to clarify this relationship(semantically)?  The use of "end-to-end" seems somewhat contrary to theuse of "between" (i.e., the latter does not include the endpoint itself).If neither of these suggestions captures your intent, please let us knowhow to rephrase.Original:...cannot in general be protected end-to-end between the endpoints.Perhaps A:...cannot, in general, be protected end-to-end.Perhaps B:...cannot, in general, be protected when between the endpoints.[Auth] Replaced with...cannot, in general, be protected end-to-end from one endpoint to the other.--><t>Most CoAP header fields (i.e., the message fields in the fixed 4-byte header) are required to be read and/or changed by CoAP proxies; thus, they cannot, in general, be protected end-to-end from one endpoint to the other. As mentioned in <xref target="intro"/>, OSCORE protects the CoAP request/response layer only and not the CoAP messaging layer (Section 2 of <xref target="RFC7252"/>), so fields such as Type and Message ID are not protected with OSCORE.</t><t>The CoAP header field Code is protected by OSCORE. Code SHALL be encrypted and integrity protected (Class E) to prevent an intermediary from eavesdropping on or manipulating it (e.g., changing from GET to DELETE).</t><t>The sending endpoint SHALL write the Code of the original CoAP message into the plaintext of the COSE object (see <xref target="plaintext"/>). After that, the sending endpoint writes an Outer Code to the OSCORE message. With one exception (see <xref target="observe"/>), the Outer Code SHALL be set to 0.02 (POST) for requests and to 2.04 (Changed) for responses. The receiving endpoint SHALL discard the Outer Code in the OSCORE message and write the Code of the COSE object plaintext (<xref target="plaintext"/>) into the decrypted CoAP message.</t><t>The other currently defined CoAP header fields are Unprotected (Class U). The sending endpoint SHALL write all other header fields of the original message into the header of the OSCORE message. The receiving endpoint SHALL write the header fields from the received OSCORE message into the header of the decrypted CoAP message.</t><t>The CoAP Payload, if present in the original CoAP message, SHALL be encrypted and integrity protected; thus, it is an Inner message field. The sending endpoint writes the payload of the original CoAP message into the plaintext (<xref target="plaintext"/>) input to the COSE object. The receiving endpoint verifies and decrypts the COSE object, and it recreates the payload of the original CoAP message.</t></section><section anchor="coap-signaling" title="Signaling Messages"><t>Signaling messages (CoAP Code 7.00-7.31) were introduced to exchange information related to an underlying transport connection in the specific case of CoAP over reliable transports <xref target="RFC8323"/>.</t><t>OSCORE MAY be used to protect Signaling if the endpoints for OSCORE coincide with the endpoints for the signaling message. If OSCORE is used to protect Signaling then:</t><t><list style="symbols">  <t>To comply with <xref target="RFC8323"/>, an initial empty Capabilities and Settings Message  (CSM) SHALL be sent. The subsequent signaling message SHALL be protected.</t>  <t>Signaling messages SHALL be protected as CoAP request messages, except in the case in which the Signaling message is a response to a previous Signaling message; then it SHALL be protected as a CoAP response message. For example, 7.02 (Ping) is protected as a CoAP request and 7.03 (Pong) as a CoAP response.</t>  <t>The Outer Code for Signaling messages SHALL be set to 0.02 (POST), unless it is a response to a previous Signaling message, in which case it SHALL be set to 2.04 (Changed).</t>  <t>All Signaling options, except the OSCORE option, SHALL be Inner (Class E).</t></list></t><t>NOTE: Option numbers for Signaling messages are specific to the CoAP Code (see Section 5.2 of <xref target="RFC8323"/>).</t><t>If OSCORE is not used to protect Signaling, Signaling messages SHALL be unaltered by OSCORE.</t></section></section><section anchor="cose-object" title="The COSE Object"><t>This section defines how to use COSE <xref target="RFC8152"/> to wrap and protect data in the original message. OSCORE uses the untagged COSE_Encrypt0 structure with an Authenticated Encryption with Additional Data (AEAD) algorithm. The AEAD key lengths, AEAD nonce length, and maximum Sender Sequence Number are algorithm dependent.</t><!--[rfced] Sometimes the text distinguishes AES-CCM-16-64-128 as an "AEAD"algorithm.  Should this be used consistently throughout?  If so, pleaseprovide us with Old/New updates so that we can correctly capture yourintent.Original:The AEAD algorithm AES-CCM-16-64-128 defined in Section 10.2 of...Original:The following is an example of AAD constructed using AEAD Algorithm =AES-CCM-16-64-128 (10), request_kid = 0x00, request_piv = 0x25 and noClass I options[Auth] We went through all the occurrences of "AES-CCM-16-64-128" (13 occurrences), and consider that it is clear from the context that AES-CCM-16-64-128 is an AEAD algorithm, so we don't have any updates regarding this comment.--><t>The AEAD algorithm AES-CCM-16-64-128 defined in Section 10.2 of <xref target="RFC8152"/> is mandatory to implement. For AES-CCM-16-64-128, the length of Sender Key and Recipient Key is 128 bits; the length of AEAD nonce and Common IV is 13 bytes. The maximum Sender Sequence Number is specified in <xref target="sec-considerations"/>.</t><t>As specified in <xref target="RFC5116"/>, plaintext denotes the data that is to be encrypted and integrity protected, and Additional Authenticated Data (AAD) denotes the data that is to be integrity protected only.</t><t>The COSE object SHALL be a COSE_Encrypt0 object with fields defined as follows:</t><t><list style="symbols">  <t>The 'protected' field is empty.</t>  <t>The 'unprotected' field includes:  <list style="symbols">      <t>The 'Partial IV' parameter. The value is set to the Sender Sequence Number. All leading bytes of value zero SHALL be removed when encoding the Partial IV, except in the case of Partial IV value 0, which is encoded to the byte string 0x00. This parameter SHALL be present in requests. The Partial IV SHALL be present in responses to Observe registrations (see <xref target="observe-registration"/>); otherwise, the Partial IV will not typically be present in responses (for one exception, see <xref target="reboot-replay"/>).</t>      <t>The 'kid' parameter. The value is set to the Sender ID. This parameter SHALL be present in requests and will not typically be present in responses. An example where the Sender ID is included in a response is the extension of OSCORE to group communication <xref target="Group-OSCORE"/>.</t>      <t>Optionally, a 'kid context' parameter (see <xref target="context-hint"/>). This parameter MAY be present in requests and, if so, MUST contain an ID Context (see <xref target="context-definition"/>). This parameter SHOULD NOT be present in responses: an example of how 'kid context' can be used in responses is given in <xref target="master-secret-multiple"/>. If 'kid context' is present in the request, then the server SHALL use a security context with that ID Context when verifying the request.</t>    </list></t>  <t>The 'ciphertext' field is computed from the secret key (Sender Key or Recipient Key), AEAD nonce (see <xref target="nonce"/>), plaintext (see <xref target="plaintext"/>), and the AAD (see <xref target="AAD"/>) following Section 5.2 of <xref target="RFC8152"/>.</t></list></t><t>The encryption process is described in Section 5.3 of <xref target="RFC8152"/>.</t><section anchor="context-hint" title="ID Context and 'kid context'"><t>For certain use cases, e.g., deployments where the same Sender ID is used with multiple contexts, it is possible (and sometimes necessary, see <xref target="req-params"/>) for the client to use an ID Context to distinguish the security contexts (see <xref target="context-definition"/>). For example:</t><t><list style="symbols">  <t>If the client has a unique identifier in some namespace, then that identifier can be used as ID Context.</t>  <t>The ID Context may be used to add randomness into new Sender and Recipient Contexts, see <xref target="master-secret-multiple"/>.</t>  <t>In the case of group communication <xref target="Group-OSCORE"/>, a group identifier is used as ID Context to enable different security contexts for a server belonging to multiple groups.</t></list></t><t>The Sender ID and ID Context are used to establish the necessary input parameters and in the derivation of the security context (see <xref target="context-derivation"/>).</t><t>While the 'kid' parameter is used to transport the Sender ID, the new COSE header parameter 'kid context' is used to transport the ID Context in requests, see <xref target="tab-1"/>.</t><figure title="Common Header Parameter 'kid context' for the COSE Object" anchor="tab-1"><artwork align="center"><![CDATA[+----------+--------+------------+----------------+-----------------+|   Name   |  Label | Value Type | Value Registry |   Description   |+----------+--------+------------+----------------+-----------------+|   kid    |    10  | bstr       |                | Identifies the  || context  |        |            |                | context for the ||          |        |            |                | key identifier  |+----------+--------+------------+----------------+-----------------+]]></artwork></figure><t>If ID Context is non-empty and the client sends a request without'kid context' resulting in an error indicating that the server couldnot find the security context, then the client could include the IDContext in the 'kid context' when making another request. Note thatsince the error is unprotected, it may have been spoofed and the realresponse blocked by an on-path attacker.</t></section><section anchor="nonce" title="AEAD Nonce">  <t>The high-level design of the AEAD nonce follows Section 4.4 of <xref target="IV-GEN"/>. The detailed construction of the AEAD nonce is presented here (see <xref target="fig-nonce"/>):</t><!--[rfced] Please confirm this text is pointing to Figure 8 in the documentmentioned in this section (we assume this is why it did not use an<xref> in the XML file).Original:   The high level design of the AEAD nonce follows Section 4.4 of   [I-D.mcgrew-iv-gen], here follows the detailed construction (see   Figure 8):   Perhaps:   The high-level design of the AEAD nonce follows Section 4.4 of   [IV-GEN]; here follows the detailed construction (see   Figure 8 of that document):[Auth] we replaced the original with:   The high-level design of the AEAD nonce follows Section 4.4 of   [IV-GEN].  The detailed construction of the AEAD nonce is presented   here (see Figure 8):Note that we actually had missed the <xref> link that we have now added (we did want to refer to Figure 8 of this document), and reformulated the text for clarity.-->  <t><list style="numbers">  <t>left-pad the Partial IV (PIV) with zeroes to exactly 5 bytes,</t>  <t>left-pad the Sender ID of the endpoint that generated the Partial IV (ID_PIV) with zeroes to exactly nonce length minus 6 bytes,</t>  <t>concatenate the size of the ID_PIV (a single byte S) with the padded ID_PIV and the padded PIV,</t>  <t>and then XOR with the Common IV.</t></list></t><t>Note that in this specification, only AEAD algorithms that use nonces equal or greater than 7 bytes are supported. The nonce construction with S, ID_PIV, and PIV together with endpoint-unique IDs and encryption keys makes it easy to verify that the nonces used with a specific key will be unique, see <xref target="kn-uniqueness"/>.</t><t>If the Partial IV is not present in a response, the nonce from the request is used. For responses that are not notifications (i.e., when there is a single response to a request), the request and the response should typically use the same nonce to reduce message overhead. Both alternatives provide all the required security properties, see <xref target="replay-protection"/> and <xref target="kn-uniqueness"/>. The only non-Observe scenario where a Partial IV must be included in a response is when the server is unable to perform replay protection, see <xref target="reboot-replay"/>. For processing instructions see <xref target="processing"/>.</t><figure title="AEAD Nonce Formation" anchor="fig-nonce"><artwork align="center"><![CDATA[     <- nonce length minus 6 B -> <-- 5 bytes -->+---+-------------------+--------+---------+-----+| S |      padding      | ID_PIV | padding | PIV |----+ +---+-------------------+--------+---------+-----+    |                                                       | <---------------- nonce length ---------------->     |               +------------------------------------------------+    | |                   Common IV                    |->(XOR)+------------------------------------------------+    |                                                       |  <---------------- nonce length ---------------->     |               +------------------------------------------------+    | |                     Nonce                      |<---+ +------------------------------------------------+     ]]></artwork></figure></section><section anchor="plaintext" title="Plaintext"><t>The plaintext is formatted as a CoAP message without header (see <xref target="fig-plaintext"/>) consisting of:</t><t><list style="symbols">  <t>the Code of the original CoAP message as defined in Section 3 of <xref target="RFC7252"/>; and</t>  <t>all Inner option message fields (see <xref target="inner-options"/>) present in the original CoAP message (see <xref target="coap-options"/>). The options are encoded as described in Section 3.1 of <xref target="RFC7252"/>, where the delta is the difference from the previously included instance of Class E option; and</t>  <t>the Payload of original CoAP message, if present, and in that case prefixed by the one-byte Payload Marker (0xff).</t></list></t><t>NOTE: The plaintext contains all CoAP data that needs to be encrypted end-to-end between the endpoints.</t><figure title="Plaintext" anchor="fig-plaintext"><artwork align="center"><![CDATA[ 0                   1                   2                   3    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|     Code      |    Class E options (if any) ...                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|1 1 1 1 1 1 1 1|    Payload (if any) ...                        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ (only if there    is payload)]]></artwork></figure></section><section anchor="AAD" title="Additional Authenticated Data"><t>The external_aad SHALL be a CBOR array wrapped in a bstr object as defined below:</t><figure><artwork type="CDDL"><![CDATA[external_aad = bstr .cbor aad_arrayaad_array = [  oscore_version : uint,  algorithms : [ alg_aead : int / tstr ],  request_kid : bstr,  request_piv : bstr,  options : bstr,]]]></artwork></figure><t>where:</t><t><list style="symbols">  <t>oscore_version: contains the OSCORE version number. Implementations of this specification MUST set this field to 1. Other values are reserved for future versions.</t>  <t>algorithms: contains (for extensibility) an array of algorithms, according to this specification only containing alg_aead.</t>  <t>alg_aead: contains the AEAD Algorithm from the security context used for the exchange (see <xref target="context-definition"/>).</t>  <t>request_kid: contains the value of the 'kid' in the COSE object of the request (see <xref target="cose-object"/>).</t>  <t>request_piv: contains the value of the 'Partial IV' in the COSE object of the request (see <xref target="cose-object"/>).</t>  <t>options: contains the Class I options (see <xref target="outer-options"/>) present in the original CoAP message encoded as described in Section 3.1 of <xref target="RFC7252"/>, where the delta is the difference from the previously included instance of class I option.</t></list></t><t>The oscore_version and algorithms parameters are established out-of-band; thus, they are transported in OSCORE, but the external_aad allows to verify that they are the same in both endpoints.</t><t>NOTE: The format of the external_aad is, for simplicity, the same for requests and responses, although some parameters, e.g., request_kid, need not be integrity protected in all requests.</t><t>The AAD is composed from the external_aad as described in Section 5.3 of <xref target="RFC8152"/>:</t><figure><artwork><![CDATA[   AAD = Enc_structure = [ "Encrypt0", h'', external_aad ]]]></artwork></figure><t>The following is an example of AAD constructed using AEAD Algorithm = AES-CCM-16-64-128 (10), request_kid = 0x00, request_piv = 0x25 and no Class I options:</t><t><list style="symbols">  <t>oscore_version: 0x01 (1 byte)</t>  <t>algorithms: 0x810a (2 bytes)</t>  <t>request_kid: 0x00 (1 byte)</t>  <t>request_piv: 0x25 (1 byte)</t>  <t>options: 0x (0 bytes)</t>  <t>aad_array: 0x8501810a4100412540 (9 bytes)</t>  <t>external_aad: 0x498501810a4100412540 (10 bytes)</t>  <t>AAD: 0x8368456e63727970743040498501810a4100412540 (21 bytes)</t></list></t><t>Note that the AAD consists of a fixed string of 11 bytes concatenated with the external_aad.</t></section></section><section anchor="compression" title="OSCORE Header Compression"><t>The Concise Binary Object Representation (CBOR) <xreftarget="RFC7049"/> combines very small message sizes withextensibility. The CBOR Object Signing and Encryption (COSE) <xreftarget="RFC8152"/> uses CBOR to create compact encoding of signed andencrypted data. However, COSE is constructed to support a large numberof different stateless use cases and is not fully optimized for use asa stateful security protocol, leading to a larger than necessarymessage expansion. In this section, we define a stateless headercompression mechanism, simply removing redundant information from theCOSE objects, which significantly reduces the per-packet overhead. Theresult of applying this mechanism to a COSE object is called the"compressed COSE object".</t><t>The COSE_Encrypt0 object used in OSCORE is transported in the OSCORE option and in the Payload. The Payload contains the ciphertext of the COSE object. The headers of the COSE object are compactly encoded as described in the next section.</t><section anchor="obj-sec-value" title="Encoding of the OSCORE Option Value"><t>The value of the OSCORE option SHALL contain the OSCORE flag bits, the Partial IV parameter, the 'kid context' parameter (length and value), and the 'kid' parameter as follows:</t><figure title="The OSCORE Option Value" anchor="fig-option-value"><artwork align="center"><![CDATA[ 0 1 2 3 4 5 6 7 <------------- n bytes -------------->+-+-+-+-+-+-+-+-+--------------------------------------|0 0 0|h|k|  n  |       Partial IV (if any) ...    +-+-+-+-+-+-+-+-+-------------------------------------- <- 1 byte -> <----- s bytes ------>                    +------------+----------------------+------------------+| s (if any) | kid context (if any) | kid (if any) ... |+------------+----------------------+------------------+]]></artwork></figure><t><list style="symbols">  <t>The first byte, containing the OSCORE flag bits, encodes the following set of bits and the length of the Partial IV parameter:  <list style="symbols">      <t>The three least significant bits encode the Partial IV length      n. If n = 0, then the Partial IV is not present in the      compressed COSE object. The values n = 6 and n = 7 are      reserved.</t>      <t>The fourth least significant bit is the 'kid' flag, k. It is set to 1 if 'kid' is present in the compressed COSE object.</t>      <t>The fifth least significant bit is the 'kid context' flag, h.  It is set to 1 if the compressed COSE object contains a 'kid context' (see <xref target="context-hint"/>).</t>      <t>The sixth-to-eighth least significant bits are reserved for      future use. These bits SHALL be set to zero when not in      use. According to this specification, if any of these bits are      set to 1, the message is considered to be malformed and      decompression fails as specified in item 2 of <xref      target="ver-req"/>.</t>    </list></t></list></t><t>The flag bits are registered in the "OSCORE Flag Bits" registry specified in <xref target="oscore-flag-bits"/>.</t><t><list style="symbols">  <t>The following n bytes encode the value of the Partial IV, if the Partial IV is present (n &gt; 0).</t><!--[rfced] Please confirm that this "s" after the mention of Section 5.1appears intentionally in this text:Original:   o  The following 1 byte encode the length of the 'kid context'      (Section 5.1) s, if the 'kid context' flag is set (h = 1).[Auth] Yes, we confirm it appears intentionally. However we see how this can be misleadeing and we reformulated:   o  The following 1 byte encodes the length s of the 'kid context'      (Section 5.1), if the 'kid context' flag is set (h = 1).-->      <t>The following 1 byte encodes the length s of the 'kid context' (<xref target="context-hint"/>), if the 'kid context' flag is set (h = 1).</t>  <t>The following s bytes encode the 'kid context', if the 'kid context' flag is set (h = 1).</t>  <t>The remaining bytes encode the value of the 'kid', if the 'kid' is present (k = 1).</t></list></t><t>Note that the 'kid' MUST be the last field of the OSCORE option value, even in the case in which reserved bits are used and additional fields are added to it.</t><t>The length of the OSCORE option thus depends on the presence andlength of Partial IV, 'kid context', 'kid', as specified in thissection, and on the presence and length of additional parameters, asdefined in the future documents registering those parameters.</t><!--[rfced] Will the reader understand what "the separate documents" refers to?  Original:   The length of the OSCORE option thus depends on the presence and   length of Partial IV, 'kid context', 'kid', as specified in this   section, and on the presence and length of the other parameters, as   defined in the separate documents.[Auth] "separate documents" referred to future documents registering new parameters (so no present documents we know of). Tried to clarify:   The length of the OSCORE option thus depends on the presence and   length of Partial IV, 'kid context', 'kid', as specified in this   section, and on the presence and length of additional parameters, as   defined in the future documents registering those parameters.--></section><section anchor="oscore-payl" title="Encoding of the OSCORE Payload"><t>The payload of the OSCORE message SHALL encode the ciphertext of the COSE object.</t></section><section anchor="examples-of-compressed-cose-objects" title="Examples of Compressed COSE Objects"><t>This section covers a list of OSCORE Header Compression examples for requests and responses. The examples assume the COSE_Encrypt0 object is set (which means the CoAP message and cryptographic material is known). Note that the full CoAP unprotected message, as well as the full security context, is not reported in the examples, but only the input necessary to the compression mechanism, i.e., the COSE_Encrypt0 object. The output is the compressed COSE object as defined in <xref target="compression"/>, divided into two parts, since the object is transported in two CoAP fields: the OSCORE option and payload.</t><t><list style="format %d." counter="bar">  <t>Request with ciphertext = 0xaea0155667924dff8a24e4cb35b9, kid = 0x25, and Partial IV = 0x05</t></list></t><figure><artwork><![CDATA[    Before compression (24 bytes):      [        h'',        { 4:h'25', 6:h'05' },        h'aea0155667924dff8a24e4cb35b9',      ]]]></artwork></figure><figure><artwork><![CDATA[    After compression (17 bytes):      Flag byte: 0b00001001 = 0x09 (1 byte)      Option Value: 0x090525 (3 bytes)      Payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes)]]></artwork></figure><t><list style="format %d." counter="bar">  <t>Request with ciphertext = 0xaea0155667924dff8a24e4cb35b9, kid = empty string, and Partial IV = 0x00</t></list></t><figure><artwork><![CDATA[    Before compression (23 bytes):      [        h'',        { 4:h'', 6:h'00' },        h'aea0155667924dff8a24e4cb35b9',      ]]]></artwork></figure><figure><artwork><![CDATA[    After compression (16 bytes):      Flag byte: 0b00001001 = 0x09 (1 byte)      Option Value: 0x0900 (2 bytes)      Payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes)]]></artwork></figure><t><list style="format %d." counter="bar">  <t>Request with ciphertext = 0xaea0155667924dff8a24e4cb35b9, kid = empty string, Partial IV = 0x05, and kid context = 0x44616c656b</t></list></t><!-- [rfced] Regarding this note in the submitted XML file:  NOTE (IANA registration) that the following example uses kid context = 8.   This might need to be changed following IANA assignment.Please send the required updates for the example, as kid context has beenassigned label 10 in the "COSE Header Parameters" registry.[Auth]  Replaced:OLD        { 4:h'', 6:h'05', 8:h'44616c656b' },NEW        { 4:h'', 6:h'05', 10:h'44616c656b' },--><figure><artwork><![CDATA[    Before compression (30 bytes):      [        h'',        { 4:h'', 6:h'05', 10:h'44616c656b' },        h'aea0155667924dff8a24e4cb35b9',      ]]]></artwork></figure><figure><artwork><![CDATA[    After compression (22  bytes):      Flag byte: 0b00011001 = 0x19 (1 byte)      Option Value: 0x19050544616c656b (8 bytes)      Payload: 0xae a0155667924dff8a24e4cb35b9 (14 bytes)]]></artwork></figure><t><list style="format %d." counter="bar">  <t>Response with ciphertext = 0xaea0155667924dff8a24e4cb35b9 and no Partial IV</t></list></t><figure><artwork><![CDATA[    Before compression (18 bytes):      [        h'',        {},        h'aea0155667924dff8a24e4cb35b9',      ]]]></artwork></figure><figure><artwork><![CDATA[    After compression (14 bytes):      Flag byte: 0b00000000 = 0x00 (1 byte)      Option Value: 0x (0 bytes)      Payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes)]]></artwork></figure><t><list style="format %d." counter="bar">  <t>Response with ciphertext = 0xaea0155667924dff8a24e4cb35b9 and Partial IV = 0x07</t></list></t><figure><artwork><![CDATA[    Before compression (21 bytes):      [        h'',        { 6:h'07' },        h'aea0155667924dff8a24e4cb35b9',      ]]]></artwork></figure><figure><artwork><![CDATA[    After compression (16 bytes):      Flag byte: 0b00000001 = 0x01 (1 byte)      Option Value: 0x0107 (2 bytes)      Payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes)]]></artwork></figure></section></section><section anchor="sequence-numbers" title="Message Binding, Sequence Numbers, Freshness, and Replay Protection"><section anchor="message-binding" title="Message Binding"><t>In order to prevent response delay and mismatch attacks <xref target="CoAP-Actuators"/> from on-path attackers and compromised intermediaries, OSCORE binds responses to the requests by including the 'kid' and Partial IV of the request in the AAD of the response. Therefore, the server needs to store the 'kid' and Partial IV of the request until all responses have been sent.</t></section><section anchor="nonce-uniqueness" title="Sequence Numbers"><t>An AEAD nonce MUST NOT be used more than once per AEAD key. The uniqueness of (key, nonce) pairs is shown in <xref target="kn-uniqueness"/>, and in particular depends on a correct usage of Partial IVs (which encode the Sender Sequence Numbers, see <xref target="cose-object"/>). If messages are processed concurrently, the operation of reading and increasing the Sender Sequence Number MUST be atomic.</t><section anchor="max-seq" title="Maximum Sequence Number"><t>The maximum Sender Sequence Number is algorithm dependent (see<xref target="sec-considerations"/>) and SHALL be less than 2^40. Ifthe Sender Sequence Number exceeds the maximum, the endpoint MUST NOTprocess any more messages with the given Sender Context. If necessary,the endpoint SHOULD acquire a new security context before thishappens. The latter is out of scope of this document.</t></section></section><section anchor="freshness" title="Freshness"><t>For requests, OSCORE provides only the guarantee that the requestis not older than the security context. For applications havingstronger demands on request freshness (e.g., control of actuators),OSCORE needs to be augmented with mechanisms providing freshness (forexample, as specified in <xref target="CoAP-ECHO-REQ-TAG"/>).</t><t>Assuming an honest server (see <xreftarget="overview-sec-properties"/>), the message binding guaranteesthat a response is not older than its request. For responses that arenot notifications (i.e., when there is a single response to arequest), this gives absolute freshness. For notifications, theabsolute freshness gets weaker with time, and it is RECOMMENDED thatthe client regularly re-register the observation. Note that themessage binding does not guarantee that a misbehaving server created theresponse before receiving the request, i.e., it does not verify serveraliveness.</t><t>For requests and notifications, OSCORE also provides relative freshness in the sense that the received Partial IV allows a recipient to determine the relative order of requests or responses.</t></section><section anchor="replay-protection" title="Replay Protection">  <t>In order to protect from replay of requests, the server's RecipientContext includes a Replay Window.<!-- [rfced] Please clarify this sentence, particularly "a Partial IV = Sender Sequence Number received in the COSE object hasnot been received before".Original:   A server SHALL verify that a   Partial IV = Sender Sequence Number received in the COSE object has   not been received before. Perhaps:   A server SHALL verify that a   Partial IV is equal to a Sender Sequence Number in the COSE object    and that it has not been received before. [Auth]We replaced with:   A server SHALL verify that the   Sender Sequence Number received in the Partial IV parameter of the   COSE object (see Section 6.1) has not been received before. -->A server SHALL verify that theSender Sequence Number received in the Partial IV parameter of theCOSE object (see <xref target="obj-sec-value"/>) hasnot been received before.If this verification fails, the server SHALL stopprocessing the message, and it MAY optionally respond with a 4.01(Unauthorized) error message. Also, the server MAY set an OuterMax-Age option with value zero to inform any intermediary that theresponse is not to be cached. The diagnostic payload MAY contain thestring "Replay detected". The size and type of the Replay Windowdepends on the use case and the protocol with which the OSCORE messageis transported. In case of reliable and ordered transport fromendpoint to endpoint, e.g., TCP, the server MAY just store the lastreceived Partial IV and require that newly received Partial IVs equalthe last received Partial IV + 1. However, in the case of mixedreliable and unreliable transports and where messages may be lost,such a replay mechanism may be too restrictive and the default replaywindow may be more suitable (see <xref target="initial-replay"/>).</t><t>Responses (with or without Partial IV) are protected against replay as they are bound to the request and the fact that only a single response is accepted. Note that the Partial IV is not used for replay protection in this case.</t><t>The operation of validating the Partial IV and updating the replay protection MUST be atomic.</t><section anchor="replay-notifications" title="Replay Protection of Notifications"><t>The following applies additionally when the Observe option is supported.</t><t>The Notification Number is initialized to the Partial IV of thefirst successfully verified notification in response to theregistration request. A client MUST only accept at most one Observenotification without Partial IV, and treat it as the oldestnotification received. A client receiving a notification containing aPartial IV SHALL compare the Partial IV with the Notification Numberassociated to that Observe registration. The client MUST stopprocessing notifications with a Partial IV that has been previouslyreceived. Applications MAY decide that a client only processesnotifications that have a greater Partial IV than the NotificationNumber.</t><t>If the verification of the response succeeds, and the receivedPartial IV was greater than the Notification Number, then the clientSHALL overwrite the corresponding Notification Number with thereceived Partial IV.</t></section></section><section anchor="context-state" title="Losing Part of the Context State"><t>To prevent reuse of an AEAD nonce with the same AEAD key or theacceptance of replayed messages, an endpoint needs to handle the situationof losing rapidly changing parts of the context, such as the SenderSequence Number and Replay Window. These are typically stored in RAMand therefore lost in the case of, e.g., an unplanned reboot. There aredifferent alternatives to recover, for example:</t><t><list style="numbers">  <t>The endpoints can reuse an existing Security Context after  updating the mutable parts of the security context (Sender Sequence  Number and Replay Window). This requires that the mutable parts of  the security context are available throughout the lifetime of the  device or that the device can establish safe security context after  loss of mutable security context data. Examples are given based on  careful use of non-volatile memory, see <xref target="seq-numb"/>  and the use of the Echo option, see <xref  target="reboot-replay"/>. If an endpoint makes use of a partial  security context stored in non-volatile memory, it MUST NOT reuse a  previous Sender Sequence Number and MUST NOT accept previously  received messages.</t>    <t>The endpoints can reuse an existing shared Master Secret and  derive new Sender and Recipient Contexts, see <xref  target="master-secret-multiple"/> for an example. This typically  requires a good source of randomness.</t>  <t>The endpoints can use a trusted third-party-assisted key establishment  protocol such as <xref target="OSCORE-PROFILE"/>. This requires the  execution of a three-party protocol and may require a good source of randomness.</t>  <t>The endpoints can run a key exchange protocol providing forward secrecy resulting in a fresh Master Secret, from which an entirely new Security Context is derived. This requires a good source of randomness, and additionally, the transmission and processing of the protocol may have a non-negligible cost, e.g., in terms of power consumption.</t></list></t><t>The endpoints need to be configured with information about which method is used. The choice of method may depend on capabilities of the devices deployed and the solution architecture. Using a key exchange protocol is necessary for deployments that require forward secrecy.</t></section></section><section anchor="processing" title="Processing"><t>This section describes the OSCORE message processing. Additional processing for Observe or Block-wise are described in subsections.</t><t>Note that, analogously to <xref target="RFC7252"/> where the Tokenand source/destination pair are used to match a response with arequest, both endpoints MUST keep the association (Token, {SecurityContext, Partial IV of the request}), in order to be able to find theSecurity Context and compute the AAD to protect or verify theresponse. The association MAY be forgotten after it has been used tosuccessfully protect or verify the response, with the exception ofObserve processing, where the association MUST be kept as long as theObservation is active.</t><t>The processing of the Sender Sequence Number follows the proceduredescribed in Section 3 of <xref target="IV-GEN"/>.</t><section anchor="prot-req" title="Protecting the Request"><t>Given a CoAP request, the client SHALL perform the following steps to create an OSCORE request:</t><t><list style="numbers">  <t>Retrieve the Sender Context associated with the target resource.</t>  <t>Compose the AAD and the plaintext, as described in Sections <xref target="plaintext" format="counter"/> and <xref target="AAD" format="counter"/>.</t>  <t>Encode the Partial IV (Sender Sequence Number in network byte order) and increment the Sender Sequence Number by one. Compute the AEAD nonce from the Sender ID, Common IV, and Partial IV as described in <xref target="nonce"/>.</t>  <t>Encrypt the COSE object using the Sender Key.&nbsp;Compress the COSE object as specified in <xref target="compression"/>.</t>  <t>Format the OSCORE message according to <xref target="protected-fields"/>. The OSCORE option is added (see <xref target="outer-options"/>).</t></list></t></section><section anchor="ver-req" title="Verifying the Request"><t>A server receiving a request containing the OSCORE option SHALL perform the following steps:</t><t><list style="numbers">  <t>Discard Code and all Class E options (marked in <xref target="fig-option-protection"/> with 'x' in column E) present in the received message. For example, an If-Match Outer option is discarded, but an Uri-Host Outer option is not discarded.</t>  <t>Decompress the COSE object (<xref target="compression"/>) and retrieve the Recipient Context associated with the Recipient ID in the 'kid' parameter, additionally using the 'kid context', if present. If either the decompression or the COSE message fails to decode, or the server fails to retrieve a Recipient Context with Recipient ID corresponding to the 'kid' parameter received, then the server SHALL stop processing the request.  <list style="symbols">      <t>If either the decompression or the COSE message fails to decode, the server MAY respond with a 4.02 (Bad Option) error message. The server MAY set an Outer Max-Age option with value zero. The diagnostic payload MAY contain the string "Failed to decode COSE".</t>      <t>If the server fails to retrieve a Recipient Context with Recipient ID corresponding to the 'kid' parameter received, the server MAY respond with a 4.01 (Unauthorized) error message. The server MAY set an Outer Max-Age option with value zero. The diagnostic payload MAY contain the string "Security context not found".</t>    </list></t>  <t>Verify that the 'Partial IV' has not been received before using the Replay Window, as described in <xref target="replay-protection"/>.</t>  <t>Compose the AAD, as described in <xref target="AAD"/>.</t>  <t>Compute the AEAD nonce from the Recipient ID, Common IV, and the 'Partial IV' parameter, received in the COSE object.</t>  <t>Decrypt the COSE object using the Recipient Key, as per Section 5.3 of <xref target="RFC8152"/>. (The decrypt operation includes the verification of the integrity.)  <list style="symbols">      <t>If decryption fails, the server MUST stop processing the request and MAY respond with a 4.00 (Bad Request) error message. The server MAY set an Outer Max-Age option with value zero. The diagnostic payload MAY contain the string "Decryption failed".</t>      <t>If decryption succeeds, update the Replay Window, as described in <xref target="sequence-numbers"/>.</t>  </list></t>  <t>Add decrypted Code, options, and payload to the decrypted request. The OSCORE option is removed.</t>  <t>The decrypted CoAP request is processed according to <xref target="RFC7252"/>.</t></list></t><section anchor="supporting-block-wise" title="Supporting Block-wise"><t>If Block-wise is supported, insert the following step before any other:</t><t>A.  If Block-wise is present in the request, then process the Outer Block options according to <xref target="RFC7959"/>, until all blocks of the request have been received (see <xref target="block-options"/>).</t></section></section><section anchor="prot-res" title="Protecting the Response"><t>If a CoAP response is generated in response to an OSCORE request, the server SHALL perform the following steps to create an OSCORE response. Note that CoAP error responses derived from CoAP processing (step 8 in <xref target="ver-req"/>) are protected, as well as successful CoAP responses, while the OSCORE errors (steps 2, 3, and 6 in <xref target="ver-req"/>) do not follow the processing below but are sent as simple CoAP responses, without OSCORE processing.</t><t><list style="numbers">  <t>Retrieve the Sender Context in the Security Context associated with the Token.</t>  <t>Compose the AAD and the plaintext, as described in Sections <xref target="plaintext" format="counter"/> and <xref target="AAD" format="counter"/>.</t>  <t>Compute the AEAD nonce as described in <xref target="nonce"/>:  <list style="symbols">      <t>Either use the AEAD nonce from the request, or</t>      <t>Encode the Partial IV (Sender Sequence Number in network byte order) and increment the Sender Sequence Number by one. Compute the AEAD nonce from the Sender ID, Common IV, and Partial IV.</t>    </list></t>  <t>Encrypt the COSE object using the Sender Key.&nbsp;Compress the COSE object as specified in <xref target="compression"/>. If the AEAD nonce was constructed from a new Partial IV, this Partial IV MUST be included in the message. If the AEAD nonce from the request was used, the Partial IV MUST NOT be included in the message.</t>  <t>Format the OSCORE message according to <xref target="protected-fields"/>. The OSCORE option is added (see <xref target="outer-options"/>).</t></list></t><section anchor="observe-prot-res" title="Supporting Observe"><t>If Observe is supported, insert the following step between step 2 and 3 of <xref target="prot-res"/>:</t><t>A. If the response is an Observe notification:</t><t><list style="symbols">  <t>If the response is the first notification:  <list style="symbols">      <t>compute the AEAD nonce as described in <xref target="nonce"/>:      <list style="symbols">          <t>Either use the AEAD nonce from the request, or</t>          <t>Encode the Partial IV (Sender Sequence Number in network byte order) and increment the Sender Sequence Number by one. Compute the AEAD nonce from the Sender ID, Common IV, and Partial IV.</t>        </list>Then, go to 4.</t>    </list></t>  <t>If the response is not the first notification:  <list style="symbols">      <t>encode the Partial IV (Sender Sequence Number in network byte order) and increment the Sender Sequence Number by one. Compute the AEAD nonce from the Sender ID, Common IV, and Partial IV, then go to 4.</t>    </list></t></list></t></section></section><section anchor="ver-res" title="Verifying the Response"><t>A client receiving a response containing the OSCORE option SHALL perform the following steps:</t><t><list style="numbers">  <t>Discard Code and all Class E options (marked in <xref target="fig-option-protection"/> with 'x' in column E) present in the received message. For example, ETag Outer option is discarded, as well as Max-Age Outer option.</t>  <t>Retrieve the Recipient Context in the Security Context associated with the Token. Decompress the COSE object (<xref target="compression"/>). If either the decompression or the COSE message fails to decode, then go to 8.</t>  <t>Compose the AAD, as described in <xref target="AAD"/>.</t>  <t>Compute the AEAD nonce  <list style="symbols">      <t>If the Partial IV is not present in the response, the AEAD nonce from the request is used.</t>      <t>If the Partial IV is present in the response, compute the AEAD nonce from the Recipient ID, Common IV, and the 'Partial IV' parameter, received in the COSE object.</t>    </list></t>  <t>Decrypt the COSE object using the Recipient Key, as per Section 5.3 <xref target="RFC8152"/>. (The decrypt operation includes the verification of the integrity.) If decryption fails, then go to 8.</t>  <t>Add decrypted Code, options and payload to the decrypted request. The OSCORE option is removed.</t>  <t>The decrypted CoAP response is processed according to <xref target="RFC7252"/>.</t>  <t>In case any of the previous erroneous conditions apply: the client SHALL stop processing the response.</t></list></t><section anchor="supporting-block-wise-1" title="Supporting Block-wise"><t>If Block-wise is supported, insert the following step before any other:</t><t>A.  If Block-wise is present in the request, then process the Outer Block options according to <xref target="RFC7959"/>, until all blocks of the request have been received (see <xref target="block-options"/>).</t></section><section anchor="observe-ver-res" title="Supporting Observe"><t>If Observe is supported:</t><t>Insert the following step between step 5 and step 6:</t><t>A. If the request was an Observe registration, then:</t><t><list style="symbols">  <t>If the Partial IV is not present in the response, and the Inner Observe option is present, and the AEAD nonce from the request was already used once, then go to 8.</t>  <t>If the Partial IV is present in the response and the Inner Observe option is present, then follow the processing described in <xref target="notifications"/> and <xref target="replay-notifications"/>, then:  <list style="symbols">      <t>initialize the Notification Number (if first successfully verified notification), or</t>      <t>overwrite the Notification Number (if the received Partial IV was greater than the Notification Number).</t>    </list></t></list></t><t>Replace step 8 of <xref target="ver-res"/> with:</t><t>B. In case any of the previous erroneous conditions apply: the client SHALL stop processing the response. An error condition occurring while processing a response to an observation request does not cancel the observation. A client MUST NOT react to failure by re-registering the observation immediately.</t></section></section></section><section anchor="web-linking" title="Web Linking"><t>The use of OSCORE MAY be indicated by a target "osc" attribute in a web link <xref target="RFC8288"/> to a resource, e.g., using a link-format document <xref target="RFC6690"/> if the resource is accessible over CoAP.</t><t>The "osc" attribute is a hint indicating that the destination of that link is only accessible using OSCORE, and unprotected access to it is not supported. Note that this is simply a hint, it does not include any security context material or any other information required to run OSCORE.</t><t>A value MUST NOT be given for the "osc" attribute; any present value MUST be ignored by parsers. The "osc" attribute MUST NOT appear more than once in a given link-value; occurrences after the first MUST be ignored by parsers.</t><t>The example in <xref target="fig-web-link"/> shows a use of the "osc" attribute: the client does resource discovery on a server and gets back a list of resources, one of which includes the "osc" attribute indicating that the resource is protected with OSCORE. The link-format notation (see Section 5 of <xref target="RFC6690"/>) is used.</t><figure title="The Web Link" anchor="fig-web-link"><artwork align="center"><![CDATA[REQ: GET /.well-known/coreRES: 2.05 Content   </sensors/temp>;osc,   </sensors/light>;if="sensor"]]></artwork></figure></section><section anchor="coap-coap-proxy" title="CoAP-to-CoAP Forwarding Proxy"><t>CoAP is designed for proxy operations (see Section 5.7 of <xref target="RFC7252"/>).</t><t>OSCORE is designed to work with OSCORE-unaware CoAP proxies. Security requirements for forwarding are listed in Section 2.2.1 of <xref target="CoAP-E2E-Sec"/>. Proxy processing of the (Outer) Proxy-Uri option works as defined in <xref target="RFC7252"/>. Proxy processing of the (Outer) Block options works as defined in <xref target="RFC7959"/>.</t><t>However, not all CoAP proxy operations are useful:</t><t><list style="symbols">  <t>Since a CoAP response is only applicable to the original CoAP request, caching is in general not useful. In support of existing proxies, OSCORE uses the Outer Max-Age option, see <xref target="max-age"/>.</t>  <t>Proxy processing of the (Outer) Observe option as defined in <xref target="RFC7641"/> is specified in <xref target="observe"/>.</t></list></t><t>Optionally, a CoAP proxy MAY detect OSCORE and act accordingly. An OSCORE-aware CoAP proxy:</t><t><list style="symbols">  <t>SHALL bypass caching for the request if the OSCORE option is present.</t>  <t>SHOULD avoid caching responses to requests with an OSCORE option.</t></list></t><t>In the case of Observe (see <xref target="observe"/>), the OSCORE-aware CoAP proxy:</t><t><list style="symbols">  <t>SHALL NOT initiate an Observe registration.</t>  <t>MAY verify the order of notifications using Partial IV rather than the Observe option.</t></list></t></section><section anchor="http-op" title="HTTP Operations"><t>The CoAP request/response model may be mapped to HTTP and vice versa as described in Section 10 of <xref target="RFC7252"/>. The HTTP-CoAP mapping is further detailed in <xref target="RFC8075"/>. This section defines the components needed to map and transport OSCORE messages over HTTP hops. By mapping between HTTP and CoAP and by using cross-protocol proxies, OSCORE may be used end-to-end between, e.g., an HTTP client and a CoAP server. Examples are provided in Sections <xref target="example-http-client-and-coap-server" format="counter"/> and <xref target="example-coap-client-and-http-server" format="counter"/>.</t><section anchor="header-field" title="The HTTP OSCORE Header Field"><t>The HTTP OSCORE header field (see <xref target="iana-http"/>) is used for carrying the content of the CoAP OSCORE option when transporting OSCORE messages over HTTP hops.</t><t>The HTTP OSCORE header field is only used in POST requests and responses  with HTTP Status Code 200 (OK). When used, the HTTP header field Content-Type is set to 'application/oscore' (see <xref target="oscore-media-type"/>) indicating that the HTTP body of this message contains the OSCORE payload (see <xref target="oscore-payl"/>). No additional semantics are provided by other message fields.</t><t>Using the Augmented Backus-Naur Form (ABNF) notation of <xref target="RFC5234"/>, including the following core ABNF syntax rules defined by that specification: ALPHA (letters) and DIGIT (decimal digits), the HTTP OSCORE header field value is as follows.</t><figure><artwork type="abnf"><![CDATA[base64url-char = ALPHA / DIGIT / "-" / "_"OSCORE = 2*base64url-char]]></artwork></figure><t>The HTTP OSCORE header field is not appropriate to list in the Connection header field (see Section 6.1 of <xref target="RFC7230"/>) since it is not hop-by-hop. OSCORE messages are generally not useful when served from cache (i.e., they will generally be marked Cache-Control: no-cache) and so interaction with Vary is not relevant (Section 7.1.4 of <xref target="RFC7231"/>). Since the HTTP OSCORE header field is critical for message processing, moving it from headers to trailers renders the message unusable in case trailers are ignored (see Section 4.1 of <xref target="RFC7230"/>).</t><t>In general, intermediaries are not allowed to insert, delete, or modify the OSCORE header. In general, changes to the HTTP OSCORE header field will violate the integrity of the OSCORE message resulting in an error. For the same reason the HTTP OSCORE header field is generally not preserved across redirects.</t><t>Since redirects are not defined in the mappings between HTTP and CoAP (<xref target="RFC8075"/> <xref target="RFC7252"/>), a number of conditions need to be fulfilled for redirects to work. For CoAP-client-to-HTTP-server redirects, such conditions include:</t><t><list style="symbols">  <t>the CoAP-to-HTTP proxy follows the redirect, instead of the CoAP client as in the HTTP case.</t>  <t>the CoAP-to-HTTP proxy copies the HTTP OSCORE header field and body to the new request.</t>  <t>the target of the redirect has the necessary OSCORE security context required to decrypt and verify the message.</t></list></t><t>Since OSCORE requires the HTTP body to be preserved across redirects, the HTTP server is RECOMMENDED to reply with 307 (Temporary Redirect) or 308 (Permanent Redirect) instead of 301 (Moved Permanently) or 302 (Found).</t><t>For the case of HTTP-client-to-CoAP-server redirects, although redirect is not defined for CoAP servers <xref target="RFC7252"/>, an HTTP client receiving a redirect should generate a new OSCORE request for the server it was redirected to.</t></section><section anchor="coap2http" title="CoAP-to-HTTP Mapping"><t>Section 10.1 of <xref target="RFC7252"/> describes the fundamentals of the CoAP-to-HTTP cross-protocol mapping process. The additional rules for OSCORE messages are as follows:</t><t><list style="symbols">  <t>The HTTP OSCORE header field value is set to:  <list style="symbols">      <t>AA if the CoAP OSCORE option is empty; otherwise,</t>      <t>the value of the CoAP OSCORE option (<xref target="obj-sec-value"/>) in base64url (Section 5 of <xref target="RFC4648"/>) encoding without padding. Implementation notes for this encoding are given in Appendix C of <xref target="RFC7515"/>.</t>    </list></t>  <t>The HTTP Content-Type is set to 'application/oscore' (see <xref target="oscore-media-type"/>), independent of CoAP Content-Format.</t></list></t></section><section anchor="http2coap" title="HTTP-to-CoAP Mapping"><t>Section 10.2 of <xref target="RFC7252"/> and <xref target="RFC8075"/> specify the behavior of an HTTP-to-CoAP proxy. The additional rules for HTTP messages with the OSCORE header field are as follows.</t><t><list style="symbols">  <t>The CoAP OSCORE option is set as follows:  <list style="symbols">      <t>empty if the value of the HTTP OSCORE header field is a single zero byte (0x00) represented by AA; otherwise,</t>      <t>the value of the HTTP OSCORE header field decoded from base64url (Section 5 of <xref target="RFC4648"/>) without padding. Implementation notes for this encoding are given in Appendix C of <xref target="RFC7515"/>.</t>    </list></t>  <t>The CoAP Content-Format option is omitted, the content format for OSCORE (<xref target="content-format"/>) MUST NOT be used.</t></list></t></section><section anchor="http-endpoints" title="HTTP Endpoints"><t>Restricted to subsets of HTTP and CoAP supporting a bijective mapping, OSCORE can be originated or terminated in HTTP endpoints.</t><t>The sending HTTP endpoint uses <xref target="RFC8075"/> to translate the HTTP message into a CoAP message. The CoAP message is then processed with OSCORE as defined in this document. The OSCORE message is then mapped to HTTP as described in <xref target="coap2http"/> and sent in compliance with the rules in <xref target="header-field"/>.</t><t>The receiving HTTP endpoint maps the HTTP message to a CoAP message using <xref target="RFC8075"/> and <xref target="http2coap"/>. The resulting OSCORE message is processed as defined in this document. If successful, the plaintext CoAP message is translated to HTTP for normal processing in the endpoint.</t></section><section anchor="example-http-client-and-coap-server" title="Example: HTTP Client and CoAP Server"><t>This section gives an example of what a request and a responsebetween an HTTP client and a CoAP server could look like. The exampleis not a test vector but intended as an illustration of how themessage fields are translated in the different steps.</t><t>Mapping and notation here is based on "Simple Form" (Section 5.4.1of <xref target="RFC8075"/>).</t><figure><artwork><![CDATA[[HTTP request -- Before client object security processing]  GET http://proxy.url/hc/?target_uri=coap://server.url/orders    HTTP/1.1]]></artwork></figure><figure><artwork><![CDATA[[HTTP request -- HTTP Client to Proxy]  POST http://proxy.url/hc/?target_uri=coap://server.url/ HTTP/1.1  Content-Type: application/oscore  OSCORE: CSU  Body: 09 07 01 13 61 f7 0f d2 97 b1 [binary]]]></artwork></figure><figure><artwork><![CDATA[[CoAP request -- Proxy to CoAP Server]  POST coap://server.url/  OSCORE: 09 25  Payload: 09 07 01 13 61 f7 0f d2 97 b1 [binary]]]></artwork></figure><figure><artwork><![CDATA[[CoAP request -- After server object security processing]  GET coap://server.url/orders ]]></artwork></figure><figure><artwork><![CDATA[[CoAP response -- Before server object security processing]  2.05 Content  Content-Format: 0  Payload: Exterminate! Exterminate!]]></artwork></figure><figure><artwork><![CDATA[[CoAP response -- CoAP Server to Proxy]  2.04 Changed  OSCORE: [empty]  Payload: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary]]]></artwork></figure><figure><artwork><![CDATA[[HTTP response -- Proxy to HTTP Client]  HTTP/1.1 200 OK  Content-Type: application/oscore  OSCORE: AA   Body: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary]]]></artwork></figure><figure><artwork><![CDATA[[HTTP response -- After client object security processing]  HTTP/1.1 200 OK  Content-Type: text/plain  Body: Exterminate! Exterminate!]]></artwork></figure><!--[rfced] Is an "HTTP Status Code 200" the same as "200 (OK) responses"?  Ifso, should these be made the same?  [Auth] Not exactly: the difference is between the Status Code of the message and the message itself. But each message contains and is characterized by a Status Code, so we implemented the following changes to align the text in the following way:OLD   Note that the HTTP Status Code 200 in the next-to-last message is the   mapping of CoAP Code 2.04 (Changed), whereas the HTTP Status Code 200   in the last message is the mapping of the CoAP Code 2.05 (Content),NEW   Note that the HTTP Status Code 200 (OK) in the next-to-last message is the   mapping of CoAP Code 2.04 (Changed), whereas the HTTP Status Code 200 (OK)   in the last message is the mapping of the CoAP Code 2.05 (Content),OLD   Note that the HTTP Code 2.04 (Changed) in the next-to-last message is   the mapping of HTTP Status Code 200,NEW   Note that the HTTP Code 2.04 (Changed) in the next-to-last message is   the mapping of HTTP Status Code 200 (OK),OLD  The HTTP OSCORE header field is only used in POST requests and 200   (OK) responses.NEW  The HTTP OSCORE header field is only used in POST requests and responses  with HTTP Status Code 200 (OK).--><t>Note that the HTTP Status Code 200 (OK) in the next-to-last message is the mapping of CoAP Code 2.04 (Changed), whereas the HTTP Status Code 200 (OK) in the last message is the mapping of the CoAP Code 2.05 (Content), which was encrypted within the compressed COSE object carried in the Body of the HTTP response.</t></section><section anchor="example-coap-client-and-http-server" title="Example: CoAP Client and HTTP Server"><t>This section gives an example of what a request and a response between a CoAP client and an HTTP server could look like.  The example is not a test vector but intended as an illustration of how the message fields are translated in the different steps.</t><figure><artwork><![CDATA[[CoAP request -- Before client object security processing]  GET coap://proxy.url/  Proxy-Uri=http://server.url/orders]]></artwork></figure><figure><artwork><![CDATA[[CoAP request -- CoAP Client to Proxy]  POST coap://proxy.url/  Proxy-Uri=http://server.url/  OSCORE: 09 25  Payload: 09 07 01 13 61 f7 0f d2 97 b1 [binary]]]></artwork></figure><figure><artwork><![CDATA[[HTTP request -- Proxy to HTTP Server]  POST http://server.url/ HTTP/1.1  Content-Type: application/oscore  OSCORE: CSU  Body: 09 07 01 13 61 f7 0f d2 97 b1 [binary]]]></artwork></figure><figure><artwork><![CDATA[[HTTP request -- After server object security processing]  GET http://server.url/orders HTTP/1.1]]></artwork></figure><figure><artwork><![CDATA[[HTTP response -- Before server object security processing]  HTTP/1.1 200 OK  Content-Type: text/plain  Body: Exterminate! Exterminate!]]></artwork></figure><figure><artwork><![CDATA[[HTTP response -- HTTP Server to Proxy]  HTTP/1.1 200 OK  Content-Type: application/oscore  OSCORE: AA  Body: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary]]]></artwork></figure><figure><artwork><![CDATA[[CoAP response -- Proxy to CoAP Client]  2.04 Changed  OSCORE: [empty]  Payload: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary]]]></artwork></figure><figure><artwork><![CDATA[[CoAP response -- After client object security processing]  2.05 Content  Content-Format: 0  Payload: Exterminate! Exterminate!]]></artwork></figure><t>Note that the HTTP Code 2.04 (Changed) in the next-to-last message is the mapping of HTTP Status Code 200 (OK), whereas the CoAP Code 2.05 (Content) in the last message is the value that was encrypted within the compressed COSE object carried in the Body of the HTTP response.</t></section></section><section anchor="sec-considerations" title="Security Considerations"><t>An overview of the security properties is given in <xref target="overview-sec-properties"/>.</t><section anchor="end-to-end-protection" title="End-to-end Protection"><t>In scenarios with intermediary nodes such as proxies or gateways, transport layer security such as (D)TLS only protects data hop-by-hop. As a consequence, the intermediary nodes can read and modify any information. The trust model where all intermediary nodes are considered trustworthy is problematic, not only from a privacy perspective, but also from a security perspective, as the intermediaries are free to delete resources on sensors and falsify commands to actuators (such as "unlock door", "start fire alarm", "raise bridge"). Even in the rare cases where all the owners of the intermediary nodes are fully trusted, attacks and data breaches make such an architecture brittle.</t><t>(D)TLS protects hop-by-hop the entire message. OSCORE protects end-to-end all information that is not required for proxy operations (see <xref target="protected-fields"/>). (D)TLS and OSCORE can be combined, thereby enabling end-to-end security of the message payload, in combination with hop-by-hop protection of the entire message, during transport between endpoint and intermediary node. In particular, when OSCORE is used with HTTP, the additional TLS protection of HTTP hops is RECOMMENDED, e.g., between an HTTP endpoint and a proxy translating between HTTP and CoAP.</t><t>Applications need to consider that certain message fields and messages types are not protected end-to-end and may be spoofed or manipulated. The consequences of unprotected message fields are analyzed in <xref target="unprot-fields"/>.</t></section><section anchor="sec-context-establish" title="Security Context Establishment"><t>The use of COSE_Encrypt0 and AEAD to protect messages as specified in this document requires an established security context. The method to establish the security context described in <xref target="context-derivation"/> is based on a common Master Secret and unique Sender IDs. The necessary input parameters may be preestablished or obtained using a key establishment protocol augmented with establishment of Sender/Recipient ID, such as a key exchange protocol or the OSCORE profile of the Authentication andAuthorization for Constrained Environments (ACE) framework <xref target="OSCORE-PROFILE"/>.<!--[rfced] How may we clarify the last portion of this sentence to make clearhow it relates to the first part?  Please rephrase.Original:   Such a procedure   must ensure that the requirements of the security context parameters   for the intended use are complied with (see Section 3.3) and also in   error situations.[Auth] Replaced with the following:   Such a procedure must ensure that   the requirements of the security context parameters for the intended   use are complied with (see Section 3.3) even in error situations.-->Such a procedure must ensure that the requirements of the security context parameters for the intended use are complied with (see <xref target="req-params"/>) even in error situations. While recipient IDs are allowed to coincide between different security contexts (see <xref target="req-params"/>), this may cause a server to process multiple verifications before finding the right security context or rejecting a message. Considerations for deploying OSCORE with a fixed Master Secret are given in <xref target="deployment-examples"/>.</t></section><section anchor="master-secret" title="Master Secret"><t>OSCORE uses HKDF <xref target="RFC5869"/> and the established inputparameters to derive the security context. The required properties ofthe security context parameters are discussed in <xreftarget="req-params"/>; in this section, we focus on the MasterSecret. In this specification, HKDF denotes the composition of theexpand and extract functions as defined in <xref target="RFC5869"/>and the Master Secret is used as Input Keying Material (IKM).</t><!--[rfced] Most RFCs expand IKM with "Keying" instead of "Key".  We have updated this text accordingly.  Please let us know any objections.Original:  ... is used as Input Key Material (IKM)Current:  ... is used as Input Keying Material (IKM).[Auth] Noted and no objections.--><t>Informally, HKDF takes as source an IKM containing some good amount of randomness but not necessarily distributed uniformly (or for which an attacker has some partial knowledge) and derive from it one or more cryptographically strong secret keys <xref target="RFC5869"/>.</t><t>Therefore, the main requirement for the OSCORE Master Secret, in addition to being secret, is that it have a good amount of randomness. The selected key establishment schemes must ensure that the necessary properties for the Master Secret are fulfilled. For pre-shared key deployments and key transport solutions such as <xref target="OSCORE-PROFILE"/>, the Master Secret can be generated offline using a good random number generator. Randomness requirements for security are described in <xref target="RFC4086"/>.</t></section><section anchor="replay-protection2" title="Replay Protection"><t>Replay attacks need to be considered in different parts of theimplementation. Most AEAD algorithms require a unique nonce for eachmessage, for which the Sender Sequence Numbers in the COSE messagefield 'Partial IV' is used. If the recipient accepts any sequencenumber larger than the one previously received, then the problem ofsequence number synchronization is avoided. With reliable transport,it may be defined that only messages with sequence numbers that areequal to the previous sequence number + 1 are accepted. An adversary maytry to induce a device reboot for the purpose of replaying a message(see <xref target="context-state"/>).</t><t>Note that sharing a security context between servers may open up for replay attacks, for example, if the Replay Windows are not synchronized.</t></section><section anchor="client-aliveness" title="Client Aliveness"><t>A verified OSCORE request enables the server to verify the identityof the entity who generated the message. However, it does not verifythat the client is currently involved in the communication, since themessage may be a delayed delivery of a previously generated request,which now reaches the server. To verify the aliveness of the clientthe server may use the Echo option in the response to a request fromthe client (see <xref target="CoAP-ECHO-REQ-TAG"/>).</t></section><section anchor="cryptographic-considerations" title="Cryptographic Considerations"><t>The maximum Sender Sequence Number is dependent on the AEADalgorithm. The maximum Sender Sequence Number is 2^40 - 1, or anyalgorithm-specific lower limit, after which a new security contextmust be generated. The mechanism to build the AEAD nonce (<xreftarget="nonce"/>) assumes that the nonce is at least 56 bits, and thePartial IV is at most 40 bits. The mandatory-to-implement AEADalgorithm AES-CCM-16-64-128 is selected for compatibility withCCM*. AEAD algorithms that require unpredictable nonces are notsupported.</t><t>In order to prevent cryptanalysis when the same plaintext isrepeatedly encrypted by many different users with distinct AEAD keys,the AEAD nonce is formed by mixing the sequence number with a secretper-context initialization vector (Common IV) derived along with thekeys (see Section 3.1 of <xref target="RFC8152"/>), and by using aMaster Salt in the key derivation (see <xref target="MF00"/> for anoverview). The Master Secret, Sender Key, Recipient Key, and Common IVmust be secret, the rest of the parameters may be public. The MasterSecret must have a good amount of randomness (see <xreftarget="master-secret"/>).</t><t>The ID Context, Sender ID, and Partial IV are always at least implicitly integrity protected, as manipulation leads to the wrong nonce or key being used and therefore results in decryption failure.</t></section><section anchor="message-segmentation" title="Message Segmentation"><t>The Inner Block options enable the sender to split large messagesinto OSCORE-protected blocks such that the receiving endpoint canverify blocks before having received the complete message. The OuterBlock options allow for arbitrary proxy fragmentation operations thatcannot be verified by the endpoints but that can, by policy, berestricted in size since the Inner Block options allow for securefragmentation of very large messages. A maximum message size (abovewhich the sending endpoint fragments the message and the receivingendpoint discards the message, if complying to the policy) may beobtained as part of normal resource discovery.</t></section><section anchor="priv-cons" title="Privacy Considerations"><t>Privacy threats executed through intermediary nodes areconsiderably reduced by means of OSCORE. End-to-end integrityprotection and encryption of the message payload and all options thatare not used for proxy operations provide mitigation against attackson sensor and actuator communication, which may have a direct impacton the personal sphere.</t><t>The unprotected options (<xref target="fig-option-protection"/>)may reveal privacy-sensitive information, see <xreftarget="unprot-fields"/>. CoAP headers sent in plaintext allow, forexample, matching of CON and ACK (CoAP Message Identifier), matchingof request and responses (Token) and traffic analysis. OSCORE does notprovide protection for HTTP header fields that are not bothCoAP-mappable and Class E. The HTTP message fields that are visibleto on-path entities are only used for the purpose of transporting theOSCORE message, whereas the application-layer message is encoded inCoAP and encrypted.</t><t>COSE message fields, i.e., the OSCORE option, may revealinformation about the communicating endpoints. For example, 'kid' and'kid context', which are intended to help the server find the rightcontext, may reveal information about the client. Tracking 'kid' and'kid context' to one server may be used for correlating requests fromone client.</t><t>Unprotected error messages reveal information about the securitystate in the communication between the endpoints. Unprotectedsignaling messages reveal information about the reliable transportused on a leg of the path. Using the mechanisms described in <xreftarget="context-state"/> may reveal when a device goes through areboot. This can be mitigated by the device storing the precise stateof Sender Sequence Number and Replay Window on a clean shutdown.</t><t>The length of message fields can reveal information about themessage. Applications may use a padding scheme to protect againsttraffic analysis.</t></section></section><section anchor="iana-considerations" title="IANA Considerations"><section anchor="cose-header-parameters-registry" title="COSE Header Parameters Registry"><t>The 'kid context' parameter has been added to the "COSE Header Parameters" registry:</t><t><list style="symbols">  <t>Name: kid context</t>  <t>Label: 10</t>  <t>Value Type: bstr</t>  <t>Value Registry:</t>  <t>Description: Identifies the context for the key identifier</t>  <t>Reference: <xref target="context-hint"/> of this document</t></list></t></section><section anchor="coap-option-numbers-registry" title="CoAP Option Numbers Registry"><t>The OSCORE option has been added to the "CoAP Option Numbers" registry:</t><figure><artwork align="center"><![CDATA[+--------+-----------------+-------------------+| Number | Name            | Reference         |+--------+-----------------+-------------------+|     9  | OSCORE          | [RFC8613]         |+--------+-----------------+-------------------+]]></artwork></figure><t>Furthermore, the following existing entries in the "CoAP Option Numbers"registry have been updated with a reference to the document specifying OSCORE processing of that option:</t><figure><artwork align="center"><![CDATA[+--------+-----------------+-------------------------------+| Number | Name            |          Reference            |+--------+-----------------+-------------------------------+|   1    | If-Match        | [RFC7252] [RFC8613]           ||   3    | Uri-Host        | [RFC7252] [RFC8613]           | |   4    | ETag            | [RFC7252] [RFC8613]           ||   5    | If-None-Match   | [RFC7252] [RFC8613]           ||   6    | Observe         | [RFC7641] [RFC8613]           ||   7    | Uri-Port        | [RFC7252] [RFC8613]           ||   8    | Location-Path   | [RFC7252] [RFC8613]           ||  11    | Uri-Path        | [RFC7252] [RFC8613]           ||  12    | Content-Format  | [RFC7252] [RFC8613]           ||  14    | Max-Age         | [RFC7252] [RFC8613]           ||  15    | Uri-Query       | [RFC7252] [RFC8613]           ||  17    | Accept          | [RFC7252] [RFC8613]           ||  20    | Location-Query  | [RFC7252] [RFC8613]           ||  23    | Block2          | [RFC7959] [RFC8323] [RFC8613] ||  27    | Block1          | [RFC7959] [RFC8323] [RFC8613] ||  28    | Size2           | [RFC7959] [RFC8613]           ||  35    | Proxy-Uri       | [RFC7252] [RFC8613]           ||  39    | Proxy-Scheme    | [RFC7252] [RFC8613]           ||  60    | Size1           | [RFC7252] [RFC8613]           || 258    | No-Response     | [RFC7967] [RFC8613]           |+--------+-----------------+-------------------------------+]]></artwork></figure><t>Future additions to the "CoAP Option Numbers" registry need to provide a reference to the document where the OSCORE processing of that CoAP Option is defined.</t></section><section anchor="coap-signaling-option-numbers-registry" title="CoAP Signaling Option Numbers Registry"><t>The OSCORE option has been added to the "CoAP Signaling Option Numbers" registry:</t><figure><artwork align="center"><![CDATA[+------------+--------+---------------------+-------------------+| Applies to | Number | Name                | Reference         |+------------+--------+---------------------+-------------------+| 7.xx (all) |     9  | OSCORE              | [RFC8613]         |+------------+--------+---------------------+-------------------+]]></artwork></figure></section><section anchor="iana-http" title="Header Field Registrations"><t>The HTTP OSCORE header field has been added to the "Message Headers" registry:</t><figure><artwork align="center"><![CDATA[+-------------------+----------+----------+---------------------+| Header Field Name | Protocol | Status   | Reference           |+-------------------+----------+----------+---------------------+| OSCORE            | http     | standard | [RFC8613],          ||                   |          |          | Section 11.1        |+-------------------+----------+----------+---------------------+]]></artwork></figure></section><section anchor="oscore-media-type" title="Media Type Registration"><t>This section registers the 'application/oscore' media type in the "MediaTypes" registry. This media type is used to indicate that the content is an OSCORE message. The OSCORE body cannot be understood without the OSCORE header field value and the security context.</t><figure><artwork><![CDATA[  Type name: application  Subtype name: oscore  Required parameters: N/A  Optional parameters: N/A  Encoding considerations: binary  Security considerations: See the Security Considerations section     of [RFC8613].  Interoperability considerations: N/A  Published specification: [RFC8613]  Applications that use this media type: IoT applications sending     security content over HTTP(S) transports.  Fragment identifier considerations: N/A  Additional information:  *  Deprecated alias names for this type: N/A  *  Magic number(s): N/A  *  File extension(s): N/A  *  Macintosh file type code(s): N/A  Person & email address to contact for further information:     IESG <iesg@ietf.org>  Intended usage: COMMON  Restrictions on usage: N/A  Author: Goeran Selander <goran.selander@ericsson.com>  Change Controller: IESG  Provisional registration?  No]]></artwork></figure></section><section anchor="content-format" title="CoAP Content-Formats Registry"><t>This section registers the media type 'application/oscore' mediatype in the "CoAP Content-Formats" registry. This Content-Format forthe OSCORE payload is defined for potential future use cases and SHALLNOT be used in the OSCORE message. The OSCORE payload cannot beunderstood without the OSCORE option value and the securitycontext.</t><figure><artwork align="center"><![CDATA[+----------------------+----------+----------+-------------------+| Media Type           | Encoding |   ID     |     Reference     |+----------------------+----------+----------+-------------------+| application/oscore   |          |  10001   | [RFC8613]         |+----------------------+----------+----------+-------------------+]]></artwork></figure></section><section anchor="oscore-flag-bits" title="OSCORE Flag Bits Registry"><t>This document defines a subregistry for the OSCORE flag bits withinthe "CoRE Parameters" registry. The name of the subregistry is "OSCOREFlag Bits". The registry has been created with the Expert Reviewpolicy <xref target="RFC8126"/>. Guidelines for the experts are provided in <xreftarget="exp-instr"/>.</t><t>The columns of the registry are as follows:</t><t><list style="symbols">  <t>Bit Position: This indicates the position of the bit in the set of OSCORE flag bits, starting at 0 for the most significant bit. The bit position must be an integer or a range of integers, in the range 0 to 63.</t>  <t>Name: The name is present to make it easier to refer to and discuss the registration entry. The value is not used in the protocol. Names are to be unique in the table.</t>  <t>Description: This contains a brief description of the use of the bit.</t>  <t>Reference: This contains a pointer to the specification defining the entry.</t></list></t><t>The initial contents of the registry are in the table below. The referencecolumn for all rows is this document. The entries withBit Position of 0 and 1 are marked as 'Reserved'. The entry with Bit Positionof 1 will be specified in a future document and will be used to expand the space for the OSCORE flag bits in <xref target="obj-sec-value"/>, so that entries 8-63 of the registry are defined.</t><figure><artwork align="center"><![CDATA[+--------------+-------------+-----------------------------+-----------+| Bit Position | Name        | Description                 | Reference |+--------------+-------------+-----------------------------+-----------+|       0      | Reserved    |                             |           |+--------------+-------------+-----------------------------+-----------+|       1      | Reserved    |                             |           |+--------------+-------------+-----------------------------+-----------+|       2      | Unassigned  |                             |           |+--------------+-------------+-----------------------------+-----------+|       3      | Kid Context | Set to 1 if kid context     | [RFC8613] ||              | Flag        | is present in the           |           ||              |             | compressed COSE object      |           |+--------------+-------------+-----------------------------+-----------+|       4      | Kid Flag    | Set to 1 if kid is present  | [RFC8613] ||              |             | in the compressed COSE      |           ||              |             | object                      |           |+--------------+-------------+-----------------------------+-----------+|     5-7      | Partial IV  | Encodes the Partial IV      | [RFC8613] ||              | Length      | length; can have value      |           ||              |             | 0 to 5                      |           |+--------------+-------------+-----------------------------+-----------+|    8-63      | Unassigned  |                             |           |+--------------+-------------+-----------------------------+-----------+]]></artwork></figure></section><section anchor="exp-instr" title="Expert Review Instructions"><t>The expert reviewers for the registry defined in this document are expected to ensure that the usage solves a valid use case that could not be solved better in a different way, that it is not going to duplicate one that is already registered, and that the registered point is likely to be used in deployments. They are furthermore expected to check the clarity of purpose and use of the requested code points. Experts should take into account the expected usage of entries when approving point assignment, and the length of the encoded value should be weighed against the number of code points left that encode to that size and the size of device it will be used on. Experts should block registration for entries 8-63 until these points are defined (i.e., until the mechanism for the OSCORE flag bits expansion via bit 1 is specified).</t></section></section>  </middle>  <back>    <references title='Normative References'>&RFC2119;&RFC4086;&RFC4648;&RFC5234;&RFC6347;&RFC7049;&RFC7230;&RFC7231;&RFC7252;&RFC7641;&RFC7959;&RFC8075;&RFC8132;&RFC8152;&RFC8174;&RFC8288;&RFC8323;&RFC8446;    </references>    <references title='Informative References'>&RFC3552;&RFC3986;&RFC5116;&RFC5869;&RFC6690;&RFC7228;&RFC7515;&RFC7967;<?rfc include="reference.RFC.8126"?><!--&I-D.ietf-ace-oauth-authz; Publication requested.  See https://datatracker.ietf.org/doc/search/?name=ietf-ace-oauth-authz&activedrafts=on&rfcs=on--><reference anchor='ACE-OAuth'><front><title>Authentication and Authorization for Constrained Environments (ACE) using the OAuth 2.0 Framework (ACE-OAuth)</title><author initials='L' surname='Seitz' fullname='Ludwig Seitz'>    <organization /></author><author initials='G' surname='Selander' fullname='Goeran Selander'>    <organization /></author><author initials='E' surname='Wahlstroem' fullname='Erik Wahlstroem'>    <organization /></author><author initials='S' surname='Erdtman' fullname='Samuel Erdtman'>    <organization /></author><author initials='H' surname='Tschofenig' fullname='Hannes Tschofenig'>    <organization /></author><date month='March' year='2019' /><abstract><t>This specification defines a framework for authentication and authorization in Internet of Things (IoT) environments called ACE- OAuth.  The framework is based on a set of building blocks including OAuth 2.0 and CoAP, thus making a well-known and widely used authorization solution suitable for IoT devices.  Existing specifications are used where possible, but where the constraints of IoT devices require it, extensions are added and profiles are defined.</t></abstract></front><seriesInfo name='Work in Progress,' value='draft-ietf-ace-oauth-authz-24' /></reference><!--&I-D.ietf-cbor-cddl; IN QUEUE; in RFC-EDITOR state as of 5/22/2019--><reference anchor='CDDL'><front><title>Concise data definition language (CDDL): a notational convention to express CBOR and JSON data structures</title><author initials='H' surname='Birkholz' fullname='Henk Birkholz'>    <organization /></author><author initials='C' surname='Vigano' fullname='Christoph Vigano'>    <organization /></author><author initials='C' surname='Bormann' fullname='Carsten Bormann'>    <organization /></author><date month='March' year='2019' /><abstract><t>This document proposes a notational convention to express CBOR data structures (RFC 7049, Concise Binary Object Representation).  Its main goal is to provide an easy and unambiguous way to express structures for protocol messages and data formats that use CBOR or JSON.</t></abstract></front><seriesInfo name='Work in Progress,' value='draft-ietf-cbor-cddl-08' /></reference><!--&I-D.bormann-6lo-coap-802-15-ie; Expired.  See https://datatracker.ietf.org/doc/search?name=bormann-6lo-coap-802-15-ie&sort=&rfcs=on&activedrafts=on&olddrafts=on--><reference anchor='CoAP-802.15.4'><front><title>Constrained Application Protocol (CoAP) over IEEE 802.15.4 Information Element for IETF</title><author initials='C' surname='Bormann' fullname='Carsten Bormann'>    <organization /></author><date month='April' day='4' year='2016' /><abstract><t>IEEE Std. 802.15.4-2015 defines Information Elements (IE), and draft- kivinen-802-15-ie defines a framework for using these IEs in IETF protocols.  The present specification defines a way to transport CoAP messages in IEs.  This can be used to perform CoAP exchanges with neighboring IEEE 802.15.4 nodes before there is IP connectivity, e.g., to configure that IP connectivity.  draft-wang-6tisch-6top-coapie demonstrates example applications of this for 6TiSCH.  Other areas of application are conceivable even in classic 6LoWPAN networks.</t></abstract></front><seriesInfo name='Work in Progress,' value='draft-bormann-6lo-coap-802-15-ie-00' /></reference><!--&I-D.hartke-core-e2e-security-reqs; Expired.  See https://datatracker.ietf.org/doc/search?name=hartke-core-e2e-security-reqs&sort=&rfcs=on&activedrafts=on&olddrafts=on --><reference anchor='CoAP-E2E-Sec'><front><title>Requirements for CoAP End-To-End Security</title><author initials='G' surname='Selander' fullname='Goeran Selander'>    <organization /></author><author initials='F' surname='Palombini' fullname='Francesca Palombini'>    <organization /></author><author initials='K' surname='Hartke' fullname='Klaus Hartke'>    <organization /></author><date month='July' day='29' year='2017' /><abstract><t>This document analyses threats to CoAP message exchanges traversing proxies and derives security requirements for mitigating those threats.</t></abstract></front><seriesInfo name='Work in Progress,' value='draft-hartke-core-e2e-security-reqs-03' /></reference><reference anchor='REST'><front><title>Architectural Styles and the Design of Network-based Software Architectures</title><author initials='R' surname='Fielding' fullname="Roy Fielding">    <organization /></author><date year='2010' /></front><seriesInfo name='Ph.D. Dissertation,' value='University of California, Irvine' /><format type="pdf" target='http://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf'/></reference><!--&I-D.mattsson-core-coap-actuators; Expired.  See https://datatracker.ietf.org/doc/search?name=mattsson-core-coap-actuators&sort=&rfcs=on&activedrafts=on&olddrafts=on--><reference anchor='CoAP-Actuators'><front><title>Controlling Actuators with CoAP</title><author initials='J' surname='Mattsson' fullname='John Mattsson'>    <organization /></author><author initials='J' surname='Fornehed' fullname='John Fornehed'>    <organization /></author><author initials='G' surname='Selander' fullname='Goeran Selander'>    <organization /></author><author initials='F' surname='Palombini' fullname='Francesca Palombini'>    <organization /></author><author initials='C' surname='Amsuess' fullname='Christian Amsuess'>    <organization /></author><date month='September' day='17' year='2018' /><abstract><t>Being able to trust information from sensors and to securely control actuators are essential in a world of connected and networking things interacting with the physical world.  In this memo we show that just using COAP with a security protocol like DTLS, TLS, or OSCORE is not enough.  We describe several serious attacks any on-path attacker can do, and discusses tougher requirements and mechanisms to mitigate the attacks.  While this document is focused on actuators, some of the attacks apply equally well to sensors.</t></abstract></front><seriesInfo name='Work in Progress,' value='draft-mattsson-core-coap-actuators-06' /></reference><!--&I-D.ietf-ace-oscore-profile; Publication requested.  See https://datatracker.ietf.org/doc/search?name=ietf-ace-oscore-profile&sort=&rfcs=on&activedrafts=on&olddrafts=on--><reference anchor='OSCORE-PROFILE'><front><title>OSCORE profile of the Authentication and Authorization for Constrained Environments Framework</title><author initials='F' surname='Palombini' fullname='Francesca Palombini'>    <organization /></author><author initials='L' surname='Seitz' fullname='Ludwig Seitz'>    <organization /></author><author initials='G' surname='Selander' fullname='Goeran Selander'>    <organization /></author><author initials='M' surname='Gunnarsson' fullname='Martin Gunnarsson'>    <organization /></author><date month='February' day='19' year='2019' /><abstract><t>This memo specifies a profile for the Authentication and Authorization for Constrained Environments (ACE) framework.  It utilizes Object Security for Constrained RESTful Environments (OSCORE) to provide communication security, server authentication, and proof-of-possession for a key owned by the client and bound to an OAuth 2.0 access token.</t></abstract></front><seriesInfo name='Work in Progress,' value='draft-ietf-ace-oscore-profile-07' /></reference><!--&I-D.ietf-core-oscore-groupcomm; I-D Exists;  See https://datatracker.ietf.org/doc/search?name=ietf-core-oscore-groupcomm&sort=&rfcs=on&activedrafts=on&olddrafts=on--><reference anchor='Group-OSCORE'><front><title>Group OSCORE - Secure Group Communication for CoAP</title><author initials='M' surname='Tiloca' fullname='Marco Tiloca'>    <organization /></author><author initials='G' surname='Selander' fullname='Goeran Selander'>    <organization /></author><author initials='F' surname='Palombini' fullname='Francesca Palombini'>    <organization /></author><author initials='J' surname='Park' fullname='Jiye Park'>    <organization /></author><date month='March' day='8' year='2019' /><abstract><t>This document describes a mode for protecting group communication over the Constrained Application Protocol (CoAP).  The proposed mode relies on Object Security for Constrained RESTful Environments (OSCORE) and the CBOR Object Signing and Encryption (COSE) format. In particular, it defines how OSCORE is used in a group communication setting, while fulfilling the same security requirements for group requests and responses.  Source authentication of all messages exchanged within the group is provided by means of digital signatures produced by the sender and embedded in the protected CoAP messages.</t></abstract></front><seriesInfo name='Work in Progress,' value='draft-ietf-core-oscore-groupcomm-04' /></reference><!--&I-D.ietf-core-echo-request-tag; I-D Exists;  See https://datatracker.ietf.org/doc/search?name=ietf-core-echo-request-tag&sort=&rfcs=on&activedrafts=on&olddrafts=on--><reference anchor='CoAP-ECHO-REQ-TAG'><front><title>CoAP: Echo, Request-Tag, and Token Processing</title><author initials='C' surname='Amsuess' fullname='Christian Amsuess'>    <organization /></author><author initials='J' surname='Mattsson' fullname='John Mattsson'>    <organization /></author><author initials='G' surname='Selander' fullname='Goeran Selander'>    <organization /></author><date month='March' day='23' year='2019' /><abstract><t>This document specifies enhancements to the Constrained Application Protocol (CoAP) that mitigate security issues in particular use cases.  The Echo option enables a CoAP server to verify the freshness of a request or to force a client to demonstrate reachability at its claimed network address.  The Request-Tag option allows the CoAP server to match Block-Wise message fragments belonging to the same request.  The updated Token processing requirements for clients ensure secure binding of responses to requests when CoAP is used with security.</t></abstract></front><seriesInfo name='Work in Progress,' value='draft-ietf-core-echo-request-tag-04' /></reference><!--&I-D.mcgrew-iv-gen; Expired.  See https://datatracker.ietf.org/doc/search?name=mcgrew-iv-gen&sort=&rfcs=on&activedrafts=on&olddrafts=on--><reference anchor='IV-GEN'><front><title>Generation of Deterministic Initialization Vectors (IVs) and Nonces</title><author initials='D' surname='McGrew' fullname='David McGrew'>    <organization /></author><date month='October' day='15' year='2013' /><abstract><t>Many cryptographic algorithms use deterministic IVs, including CTR, GCM, CCM, GMAC.  This type of IV is also called a (deterministic) nonce.  Deterministic IVs must be distinct, for each fixed key, to guarantee the security of the algorithm.  This note describes best practices for the generation of such IVs, and summarizes how they are generated and used in different protocols.  Some problem areas are highlighted, and test considerations are outlined.  This note will be useful to implementers of algorithms using deterministic IVs, and to protocol or system designers using them.</t></abstract></front><seriesInfo name='Work in Progress,' value='draft-mcgrew-iv-gen-03' /></reference><reference anchor="MF00" >  <front>    <title>Attacks on Additive Encryption of Redundant Plaintext and Implications on Internet Security</title>    <author initials="D." surname="McGrew">      <organization></organization>    </author>    <author initials="S." surname="Fluhrer">      <organization></organization>    </author>    <date year="2000"/>  </front>  <seriesInfo name="Proceedings of the Seventh Annual Workshop on Selected Areas in Cryptography (SAC 2000)" value="Springer-Verlag."/>  <seriesInfo name="pp." value="14-28"/></reference>    </references><section anchor="examples" title="Scenario Examples"><t>This section gives examples of OSCORE, targeting scenarios in Section 2.2.1.1 of <xref target="CoAP-E2E-Sec"/>. The message exchanges are made, based on the assumption that there is a security context established between client and server. For simplicity, these examples only indicate the content of the messages without going into detail of the (compressed) COSE message format.</t><section anchor="secure-access-to-sensor" title="Secure Access to Sensor"><t>This example illustrates a client requesting the alarm status from a server.</t><figure title="Secure Access to Sensor" anchor="fig-alarm"><artwork align="center"><![CDATA[Client  Proxy  Server  |       |       |  +------>|       |            Code: 0.02 (POST)  | POST  |       |           Token: 0x8c  |       |       |          OSCORE: [kid:5f, Partial IV:42]  |       |       |         Payload: {Code:0.01,  |       |       |                   Uri-Path:"alarm_status"}  |       |       |  |       +------>|            Code: 0.02 (POST)  |       | POST  |           Token: 0x7b  |       |       |          OSCORE: [kid:5f, Partial IV:42]  |       |       |         Payload: {Code:0.01,  |       |       |                   Uri-Path:"alarm_status"}  |       |       |  |       |<------+            Code: 2.04 (Changed)  |       |  2.04 |           Token: 0x7b  |       |       |          OSCORE: -  |       |       |         Payload: {Code:2.05, "0"}  |       |       |  |<------+       |            Code: 2.04 (Changed)  |  2.04 |       |           Token: 0x8c  |       |       |          OSCORE: -  |       |       |         Payload: {Code:2.05, "0"}  |       |       |  ]]></artwork><postamble>Square brackets [ ... ] indicate content of compressed COSE object. Curly brackets { ... } indicate encrypted data.</postamble></figure><t>The CoAP request/response Codes are encrypted by OSCORE and only dummy Codes (POST/Changed) are visible in the header of the OSCORE message. The option Uri-Path ("alarm_status") and payload ("0") are encrypted.</t><t>The COSE header of the request contains an identifier (5f), indicating which security context was used to protect the message and a Partial IV (42).</t><t>The server verifies the request as specified in <xref target="ver-req"/>. The client verifies the response as specified in <xref target="ver-res"/>.</t></section><section anchor="secure-subscribe-to-sensor" title="Secure Subscribe to Sensor"><t>This example illustrates a client requesting subscription to a blood sugar measurement resource (GET /glucose), first receiving the value 220 mg/dl and then a second value 180 mg/dl.</t><figure title="Secure Subscribe to Sensor" anchor="fig-blood-sugar"><artwork align="center"><![CDATA[Client  Proxy  Server  |       |       |  +------>|       |            Code: 0.05 (FETCH)  | FETCH |       |           Token: 0x83  |       |       |         Observe: 0  |       |       |          OSCORE: [kid:ca, Partial IV:15]  |       |       |         Payload: {Code:0.01,  |       |       |                   Uri-Path:"glucose"}  |       |       |  |       +------>|            Code: 0.05 (FETCH)  |       | FETCH |           Token: 0xbe  |       |       |         Observe: 0  |       |       |          OSCORE: [kid:ca, Partial IV:15]  |       |       |         Payload: {Code:0.01,  |       |       |                   Uri-Path:"glucose"}  |       |       |  |       |<------+            Code: 2.05 (Content)  |       |  2.05 |           Token: 0xbe  |       |       |         Observe: 7  |       |       |          OSCORE: [Partial IV:32]  |       |       |         Payload: {Code:2.05,     |       |       |                   Content-Format:0, "220"}  |       |       |  |<------+       |            Code: 2.05 (Content)  |  2.05 |       |           Token: 0x83  |       |       |         Observe: 7  |       |       |          OSCORE: [Partial IV:32]  |       |       |         Payload: {Code:2.05,     |       |       |                   Content-Format:0, "220"} ...     ...     ...  |       |       |  |       |<------+            Code: 2.05 (Content)  |       |  2.05 |           Token: 0xbe  |       |       |         Observe: 8  |       |       |          OSCORE: [Partial IV:36]  |       |       |         Payload: {Code:2.05,  |       |       |                   Content-Format:0, "180"}  |       |       |  |<------+       |            Code: 2.05 (Content)  |  2.05 |       |           Token: 0x83  |       |       |         Observe: 8  |       |       |          OSCORE: [Partial IV:36]  |       |       |         Payload: {Code:2.05,  |       |       |                   Content-Format:0, "180"}  |       |       |]]></artwork><postamble>Square brackets [ ... ] indicate content of compressed COSE object header.Curly brackets { ... } indicate encrypted data.</postamble></figure><t>The dummy Codes (FETCH/Content) are used to allow forwarding of Observe messages. The options Content-Format (0) and the payload ("220" and "180") are encrypted.</t><t>The COSE header of the request contains an identifier (ca), indicating the security context used to protect the message and a Partial IV (15). The COSE headers of the responses contains Partial IVs (32 and 36).</t><t>The server verifies that the Partial IV has not been received before. The client verifies that the responses are bound to the request and that the Partial IVs are greater than any Partial IV previously received in a response bound to the request.</t></section></section><section anchor="deployment-examples" title="Deployment Examples"><t>For many Internet of Things (IoT) deployments, a 128-bit uniformlyrandom Master Key is sufficient for encrypting all data exchanged withthe IoT device throughout its lifetime. Two examples are given in thissection. In the first example, the security context is only derivedonce from the Master Secret. In the second example, security contextsare derived multiple times using random inputs.</t><section anchor="master-secret-once" title="Security Context Derived Once"><t>An application that only derives the security context once needs tohandle the loss of mutable security context parameters, e.g., due toreboot.</t><section anchor="seq-numb" title="Sender Sequence Number"><t>In order to handle loss of Sender Sequence Numbers, the device mayimplement procedures for writing to non-volatile memory during normaloperations and updating the security context after reboot, providedthat the procedures comply with the requirements on the securitycontext parameters (<xref target="req-params"/>). This section givesan example of such a procedure.</t><t>There are known issues related to writing to non-volatilememory. For example, flash drives may have a limited number of eraseoperations during its lifetime. Also, the time for a write operationto non-volatile memory to be completed may be unpredictable, e.g., dueto caching, which could result in important security context data notbeing stored at the time when the device reboots.</t><t>However, many devices have predictable limits for writing to non-volatile memory, are physically limited to only send a small amount of messages per minute, and may have no good source of randomness.</t><!--[rfced] May we make use of the abbreviation of these terms earlierin the document or in lieu of the expanded forms?SSNPIV (we assume this is not desirable for the quoted parameter name)AAD[auth] - For readability in the text we'd rather not use the abbreviation of Sender Sequence Number. The only point where we think it would be useful is where the formula is used (SSN2 = SSN1 + K + F). We removed SSN from the sentence below, but kept SSN1 and SSN2.- PIV is not exactly equivalent to the Partial IV which is contained in the message. For example, even when processing a response, PIV could be the Partial IV of the request (the response would not contain any Partial IV). To clarify, we did the following change:OLD:   Since the Common IV is fixed, the nonces are determined by a Partial   IV (PIV) and the Sender ID of the endpoint generating that Partial IV   (ID_PIV).NEW:   Since the Common IV is fixed, the nonces are determined by PIV, where   PIV takes the value of the Partial IV of the request or of the   response, and by the Sender ID of the endpoint generating that   Partial IV (ID_PIV).- Yes, we replaced all instances of Additional Authenticated Data with AAD, except for the first one.--><t>To prevent reuse of Sender Sequence Number, an endpoint may perform the following procedure during normal operations:</t><t><list style="symbols">  <t>Before using a Sender Sequence Number that is evenly divisible by K,  where K is a positive integer, store the Sender Sequence Number (SSN1) in  no n-volatile memory. <!-- [rfced] May instances of "after boot" be changed to "after boot time"or "after booting"? Even though the phrase "after boot" seems parallel to "after reboot", it sounds odd. There are 4 instances.Original: After boot, the endpoint initiates the ...Perhaps:  After boot time, the endpoint initiates the ...[Auth] We replaced the 4 instances of "after boot" to "after booting".-->After booting, the endpoint initiates the new Sender Sequence Number (SSN2) to the value stored in persistent memory plus K plus F: SSN2 = SSN1 + K + F, where F is a positive integer.  <list style="symbols">      <t>Writing to non-volatile memory can be costly; the value K gives a trade-off between frequency of storage operations and efficient use of Sender Sequence Numbers.</t>      <t>Writing to non-volatile memory may be subject to delays, or failure; F MUST be set so that the last Sender Sequence Number used before reboot is never larger than SSN2.</t>    </list></t></list></t><t>If F cannot be set so SSN2 is always larger than the last Sender Sequence Number used before reboot, the method described in this section MUST NOT be used.</t></section><section anchor="reboot-replay" title="Replay Window"><t>In case of loss of security context on the server, to prevent accepting replay of previously received requests, the server may perform the following procedure after booting:</t><t><list style="symbols">  <t>The server updates its Sender Sequence Number as specified in <xref target="seq-numb"/> to be used as Partial IV in the response containing the Echo option (next bullet).</t>  <t>For each stored security context, the first time after booting, the  server receives an OSCORE request, the server responds with an  OSCORE protected 4.01 (Unauthorized), containing only the Echo  option <xref target="CoAP-ECHO-REQ-TAG"/> and no diagnostic  payload. The server MUST use its Partial IV when generating the AEAD  nonce and MUST include the Partial IV in the response (see <xref  target="cose-object"/>). If the server with use of the Echo option  can verify a second OSCORE request as fresh, then the Partial IV of  the second request is set as the lower limit of the Replay Window of  that security context.</t></list></t></section><section anchor="replay-notif" title="Notifications"><t>To prevent the acceptance of replay of previously received notifications, the client may perform the following procedure after booting:</t><t><list style="symbols">  <t>The client forgets about earlier registrations and removes all Notification Numbers and registers using the Observe option.</t></list></t></section></section><section anchor="master-secret-multiple" title="Security Context Derived Multiple Times"><t>An application that does not require forward secrecy may allow multiple security contexts to be derived from one Master Secret. The requirements on the security context parameters MUST be fulfilled (<xref target="req-params"/>) even if the client or server is rebooted, recommissioned, or in error cases.</t><t>This section gives an example of a protocol that adds randomness tothe ID Context parameter and uses that together with input parameterspreestablished between client and server, in particular Master Secret,Master Salt, and Sender/Recipient ID (see <xreftarget="context-derivation"/>), to derive new security contexts. Therandom input is transported between client and server in the 'kidcontext' parameter. This protocol MUST NOT be used unless bothendpoints have good sources of randomness.</t><t>During normal requests, the ID Context of an established securitycontext may be sent in the 'kid context', which, together with 'kid',facilitates for the server to locate a securitycontext. Alternatively, the 'kid context' may be omitted since the IDContext is expected to be known to both client and server; see <xreftarget="context-hint"/>.</t><t>The protocol described in this section may only be needed when themutable part of security context is lost in the client or server,e.g., when the endpoint has rebooted. The protocol may additionally beused whenever the client and server need to derive a new securitycontext. For example, if a device is provisioned with one fixed set ofinput parameters (including Master Secret, Sender and RecipientIdentifiers), then a randomized ID Context ensures that the securitycontext is different for each deployment.</t><t>The protocol is described below with reference to <xref target="fig-B2"/>. The client or the server may initiate the protocol, in the latter case step 1 is omitted.</t><figure title="Protocol for Establishing a New Security Context" anchor="fig-B2"><artwork align="center"><![CDATA[                      Client                Server                        |                      |1. Protect with         |      request #1      |   ID Context = ID1     |--------------------->| 2. Verify with                        |  kid_context = ID1   |    ID Context = ID1                        |                      |                         |      response #1     |    Protect with3. Verify with          |<---------------------|    ID Context = R2||ID1   ID Context = R2||ID1 |   kid_context = R2   |                        |                      |   Protect with         |      request #2      |   ID Context = R2||R3  |--------------------->| 4. Verify with                         | kid_context = R2||R3 |    ID Context = R2||R3                        |                      |                         |      response #2     |    Protect with5. Verify with          |<---------------------|    ID Context = R2||R3   ID Context = R2||R3  |                      | ]]></artwork></figure><t><list style="numbers">  <t>(Optional) If the client does not have a valid security context  with the server, e.g., because of reboot or because this is the  first time it contacts the server, then it generates a random string  R1 and uses this as ID Context together with the input parameters  shared with the server to derive a first security context. The  client sends an OSCORE request to the server protected with the  first security context, containing R1 wrapped in a CBOR bstr as 'kid  context'. The request may target a special resource used for  updating security contexts.</t>    <t>The server receives an OSCORE request for which it does not have  a valid security context, either because the client has generated a  new security context ID1 = R1 or because the server has lost part  of its security context, e.g., ID Context, Sender Sequence Number or  Replay Window. If the server is able to verify the request (see  <xref target="ver-req"/>) with the new derived first security  context using the received ID1 (transported in 'kid context') as ID  Context and the input parameters associated to the received 'kid',  then the server generates a random string R2 and derives a second  security context with ID Context = ID2 = R2 || ID1. The server sends  a 4.01 (Unauthorized) response protected with the second security  context, containing R2 wrapped in a CBOR bstr as 'kid context', and  caches R2. R2 MUST NOT be reused as that may lead to reuse of key  and nonce in response #1. Note that the server may receive several  requests #1 associated with one security context, leading to  multiple parallel protocol runs. Multiple instances of R2 may need  to be cached until one of the protocol runs is completed, see <xref  target="impl-cons"/>.</t>    <t>The client receives a response with 'kid context' containing a  CBOR bstr wrapping R2 to an OSCORE request it made with ID Context =  ID1. The client derives a second security context using ID Context =  ID2 = R2 || ID1. If the client can verify the response (see <xref  target="ver-res"/>) using the second security context, then the  client makes a request protected with a third security context  derived from ID Context = ID3 = R2 || R3, where R3 is a random byte  string generated by the client. The request includes R2 || R3  wrapped in a CBOR bstr as 'kid context'.</t>    <t>If the server receives a request with 'kid context' containing a  CBOR bstr wrapping ID3, where the first part of ID3 is identical to  an R2 sent in a previous response #1, which it has not received  before, then the server derives a third security context with ID  Context = ID3. The server MUST NOT accept replayed request #2  messages. If the server can verify the request (see <xref  target="ver-req"/>) with the third security context, then the server  marks the third security context to be used with this client and  removes all instances of R2 associated to this security context from  the cache. This security context replaces the previous security  context with the client, and the first and the second security  contexts are deleted. The server responds using the same security  context as in the request.</t>    <t>If the client receives a response to the request with the third  security context and the response verifies (see <xref  target="ver-res"/>), then the client marks the third security  context to be used with this server. This security context replaces  the previous security context with the server, and the first and  second security contexts are deleted.</t></list></t><t>If verification fails in any step, the endpoint stops processing that message.</t><t>The length of the nonces R1, R2, and R3 is applicationspecific. The application needs to set the length of each nonce such thatthe probability of its value being repeated is negligible; typically,at least 8 bytes long. Since R2 may be generated as the result of areplayed request #1, the probability for collision of R2s is impactedby the birthday paradox. For example, setting the length of R2 to 8bytes results in an average collision after 2^32 response #1 messages,which should not be an issue for a constrained server handling on theorder of one request per second.</t><t>Request #2 can be an ordinary request. The server performs theaction of the request and sends response #2 after having successfullycompleted the operations related to the security context in step 4. Theclient acts on response #2 after having successfully completed step5.</t><t>When sending request #2, the client is assured that the Sender Key(derived with the random value R3) has never been used before. Whenreceiving response #2, the client is assured that the response(protected with a key derived from the random value R3 and the MasterSecret) was created by the server in response to request #2.</t><t>Similarly, when receiving request #2, the server is assured thatthe request (protected with a key derived from the random value R2 andthe Master Secret) was created by the client in response to response#1. When sending response #2, the server is assured that the SenderKey (derived with the random value R2) has never been used before.</t><t>Implementation and denial-of-service considerations are made in<xref target="impl-cons"/> and <xref target="attack-cons"/>.</t><section anchor="impl-cons" title="Implementation Considerations"><t>This section add some implementation considerations to the protocol described in the previous section.</t><!--[rfced] Should occurrences of "non-mutable" be updated to "immutable"?For example:  The server may legitimately receive multiple request #1 messages   using the same non-mutable security context...[Auth]Yes (2 instances replaced). For the sentence below, we replaced with:NEW:   The server may   legitimately receive multiple request #1 messages using the same    immutable parts of the security context, e.g., because of packet loss.--><t>The server may only have space for a few security contexts or onlybe able to handle a few protocol runs in parallel.  The server maylegitimately receive multiple request #1 messages using the sameimmutable security context, e.g., because of packet loss. Replays of oldrequest #1 messages could be difficult for the server to distinguishfrom legitimate. The server needs to handle the case when the maximumnumber of cached R2s is reached. If the server receives a request #1and is not capable of executing it then it may respond with anunprotected 5.03 (Service Unavailable). The server may clear up statefrom protocol runs that never complete, e.g., set a timer whencaching R2, and remove R2 and the associated security contexts fromthe cache at timeout. Additionally, state information can be flushedat reboot.</t><t>As an alternative to caching R2, the server could generate R2 insuch a way that it can be sent (in response #1) and verified (atreception of request #2) as the value of R2 it had generated. Such aprocedure MUST NOT lead to the server accepting replayed request #2messages. One construction described in the following is based onusing a secret random HMAC key K_HMAC per set of immutable securitycontext parameters associated with a client. This construction allowsthe server to handle verification of R2 in response #2 at the cost ofstoring the K_HMAC keys and a slightly larger message overhead inresponse #1. Steps below refer to modifications to <xreftarget="master-secret-multiple"/>:</t><t><list style="symbols">  <t>In step 2, R2 is generated in the following way. First, the server generates a random K_HMAC (unless it already has one associated with the security context), then it sets R2 = S2 || HMAC(K_HMAC, S2) where S2 is a random byte string, and the HMAC is truncated to 8 bytes. K_HMAC may have an expiration time, after which it is erased. Note that neither R2, S2, nor the derived first and second security contexts need to be cached.</t>  <t>In step 4, instead of verifying that R2 coincides with a cached value, the server looks up the associated K_HMAC and verifies the truncated HMAC, and the processing continues accordingly depending on verification success or failure.  K_HMAC is used until a run of the protocol is completed (after verification of request #2), or until it expires (whatever comes first), after which K_HMAC is erased. (The latter corresponds to removing the cached values of R2 in step 4 of <xref target="master-secret-multiple"/> and makes the server reject replays of request #2.)</t></list></t><t>The length of S2 is application specific and the probability for collision of S2s is impacted by the birthday paradox. For example, setting the length of S2 to 8 bytes results in an average collision after 2^32 response #1 messages, which should not be an issue for a constrained server handling on the order of one request per second.</t><t>Two endpoints sharing a security context may accidentally initiatetwo instances of the protocol at the same time, each in the role ofclient, e.g., after a power outage affecting both endpoints. Such arace condition could potentially lead to both protocols failing, andboth endpoints repeatedly reinitiating the protocol withoutconverging. Both endpoints can detect this situation, and it can behandled in different ways. The requests could potentially be morespread out in time, for example, by only initiating this protocol whenthe endpoint actually needs to make a request, potentially adding arandom delay before requests immediately after reboot or if suchparallel protocol runs are detected.</t></section><section anchor="attack-cons" title="Attack Considerations"><t>An on-path attacker may inject a message causing the endpoint to process verification of the message. A message crafted without access to the Master Secret will fail to verify.</t><t>Replaying an old request with a value of 'kid_context' that theserver does not recognize could trigger the protocol. This causes theserver to generate the first and second security context and send aresponse. But if the client did not expect a response, it will bediscarded. This may still result in a denial-of-service attack againstthe server, e.g., because of not being able to manage the stateassociated with many parallel protocol runs, and it may preventlegitimate client requests. Implementation alternatives with less datacaching per request #1 message are favorable in this respect; see<xref target="impl-cons"/>.</t><t>Replaying response #1 in response to some request other thanrequest #1 will fail to verify, since response #1 is associated torequest #1, through the dependencies of ID Contexts and the Partial IVof request #1 included in the external_aad of response #1.</t><t>If request #2 has already been well received, then the server has avalid security context, so a replay of request #2 is handled by thenormal replay protection mechanism. Similarly, if response #2 hasalready been received, a replay of response #2 to some other requestfrom the client will fail by the normal verification of binding ofresponse to request.</t></section></section></section><section anchor="test-vectors" title="Test Vectors"><t>This appendix includes the test vectors for different examples of CoAP messages using OSCORE. Given a set of inputs, OSCORE defines how to set up the Security Context in both the client and the server.</t><t>Note that in <xref target="tv4"/> and all following test vectors the Token and the Message ID of the OSCORE-protected CoAP messages are set to the same value of the unprotected CoAP message to help the reader with comparisons.</t><section anchor="key-der-tv-ms" title="Test Vector 1: Key Derivation with Master Salt"><t>In this test vector, a Master Salt of 8 bytes is used. The default values are used for AEAD Algorithm and HKDF.</t><section anchor="client" title="Client"><t>Inputs:</t><t><list style="symbols">  <t>Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes)</t>  <t>Master Salt: 0x9e7ca92223786340 (8 bytes)</t>  <t>Sender ID: 0x (0 byte)</t>  <t>Recipient ID: 0x01 (1 byte)</t></list></t><t>From the previous parameters,</t><t><list style="symbols">  <t>info (for Sender Key): 0x8540f60a634b657910 (9 bytes)</t>  <t>info (for Recipient Key): 0x854101f60a634b657910 (10 bytes)</t>  <t>info (for Common IV): 0x8540f60a6249560d (8 bytes)</t></list></t><t>Outputs:</t><t><list style="symbols">  <t>Sender Key: 0xf0910ed7295e6ad4b54fc793154302ff (16 bytes)</t>  <t>Recipient Key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)</t>  <t>Common IV: 0x4622d4dd6d944168eefb54987c (13 bytes)</t></list></t><t>From the previous parameters and a Partial IV equal to 0 (both for sender and recipient):</t><t><list style="symbols">  <t>sender nonce: 0x4622d4dd6d944168eefb54987c (13 bytes)</t>  <t>recipient nonce: 0x4722d4dd6d944169eefb54987c (13 bytes)</t></list></t></section><section anchor="server" title="Server"><t>Inputs:</t><t><list style="symbols">  <t>Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes)</t>  <t>Master Salt: 0x9e7ca92223786340 (8 bytes)</t>  <t>Sender ID: 0x01 (1 byte)</t>  <t>Recipient ID: 0x (0 byte)</t></list></t><t>From the previous parameters,</t><t><list style="symbols">  <t>info (for Sender Key): 0x854101f60a634b657910 (10 bytes)</t>  <t>info (for Recipient Key): 0x8540f60a634b657910 (9 bytes)</t>  <t>info (for Common IV): 0x8540f60a6249560d (8 bytes)</t></list></t><t>Outputs:</t><t><list style="symbols">  <t>Sender Key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)</t>  <t>Recipient Key: 0xf0910ed7295e6ad4b54fc793154302ff (16 bytes)</t>  <t>Common IV: 0x4622d4dd6d944168eefb54987c (13 bytes)</t></list></t><t>From the previous parameters and a Partial IV equal to 0 (both for sender and recipient):</t><t><list style="symbols">  <t>sender nonce: 0x4722d4dd6d944169eefb54987c (13 bytes)</t>  <t>recipient nonce: 0x4622d4dd6d944168eefb54987c (13 bytes)</t></list></t></section></section><section anchor="key-der-tv" title="Test Vector 2: Key Derivation without Master Salt"><t>In this test vector, the default values are used for AEAD Algorithm, HKDF, and Master Salt.</t><section anchor="client-1" title="Client"><t>Inputs:</t><t><list style="symbols">  <t>Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes)</t>  <t>Sender ID: 0x00 (1 byte)</t>  <t>Recipient ID: 0x01 (1 byte)</t></list></t><t>From the previous parameters,</t><t><list style="symbols">  <t>info (for Sender Key): 0x854100f60a634b657910 (10 bytes)</t>  <t>info (for Recipient Key): 0x854101f60a634b657910 (10 bytes)</t>  <t>info (for Common IV): 0x8540f60a6249560d (8 bytes)</t></list></t><t>Outputs:</t><t><list style="symbols">  <t>Sender Key: 0x321b26943253c7ffb6003b0b64d74041 (16 bytes)</t>  <t>Recipient Key: 0xe57b5635815177cd679ab4bcec9d7dda (16 bytes)</t>  <t>Common IV: 0xbe35ae297d2dace910c52e99f9 (13 bytes)</t></list></t><t>From the previous parameters and a Partial IV equal to 0 (both for sender and recipient):</t><t><list style="symbols">  <t>sender nonce: 0xbf35ae297d2dace910c52e99f9 (13 bytes)</t>  <t>recipient nonce: 0xbf35ae297d2dace810c52e99f9 (13 bytes)</t></list></t></section><section anchor="server-1" title="Server"><t>Inputs:</t><t><list style="symbols">  <t>Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes)</t>  <t>Sender ID: 0x01 (1 byte)</t>  <t>Recipient ID: 0x00 (1 byte)</t></list></t><t>From the previous parameters,</t><t><list style="symbols">  <t>info (for Sender Key): 0x854101f60a634b657910 (10 bytes)</t>  <t>info (for Recipient Key): 0x854100f60a634b657910 (10 bytes)</t>  <t>info (for Common IV): 0x8540f60a6249560d (8 bytes)</t></list></t><t>Outputs:</t><t><list style="symbols">  <t>Sender Key: 0xe57b5635815177cd679ab4bcec9d7dda (16 bytes)</t>  <t>Recipient Key: 0x321b26943253c7ffb6003b0b64d74041 (16 bytes)</t>  <t>Common IV: 0xbe35ae297d2dace910c52e99f9 (13 bytes)</t></list></t><t>From the previous parameters and a Partial IV equal to 0 (both for sender and recipient):</t><t><list style="symbols">  <t>sender nonce: 0xbf35ae297d2dace810c52e99f9 (13 bytes)</t>  <t>recipient nonce: 0xbf35ae297d2dace910c52e99f9 (13 bytes)</t></list></t></section></section><section anchor="key-der-kc" title="Test Vector 3: Key Derivation with ID Context"><t>In this test vector, a Master Salt of 8 bytes and an ID Context of 8 bytes are used. The default values are used for AEAD Algorithm and HKDF.</t><section anchor="client-2" title="Client"><t>Inputs:</t><t><list style="symbols">  <t>Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes)</t>  <t>Master Salt: 0x9e7ca92223786340 (8 bytes)</t>  <t>Sender ID: 0x (0 byte)</t>  <t>Recipient ID: 0x01 (1 byte)</t>  <t>ID Context: 0x37cbf3210017a2d3 (8 bytes)</t></list></t><t>From the previous parameters,</t><t><list style="symbols">  <t>info (for Sender Key): 0x85404837cbf3210017a2d30a634b657910 (17 bytes)</t>  <t>info (for Recipient Key): 0x8541014837cbf3210017a2d30a634b657910 (18 bytes)</t>  <t>info (for Common IV): 0x85404837cbf3210017a2d30a6249560d (16 bytes)</t></list></t><t>Outputs:</t><t><list style="symbols">  <t>Sender Key: 0xaf2a1300a5e95788b356336eeecd2b92 (16 bytes)</t>  <t>Recipient Key: 0xe39a0c7c77b43f03b4b39ab9a268699f (16 bytes)</t>  <t>Common IV: 0x2ca58fb85ff1b81c0b7181b85e (13 bytes)</t></list></t><t>From the previous parameters and a Partial IV equal to 0 (both for sender and recipient):</t><t><list style="symbols">  <t>sender nonce: 0x2ca58fb85ff1b81c0b7181b85e (13 bytes)</t>  <t>recipient nonce: 0x2da58fb85ff1b81d0b7181b85e (13 bytes)</t></list></t></section><section anchor="server-2" title="Server"><t>Inputs:</t><t><list style="symbols">  <t>Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes)</t>  <t>Master Salt: 0x9e7ca92223786340 (8 bytes)</t>  <t>Sender ID: 0x01 (1 byte)</t>  <t>Recipient ID: 0x (0 byte)</t>  <t>ID Context: 0x37cbf3210017a2d3 (8 bytes)</t></list></t><t>From the previous parameters,</t><t><list style="symbols">  <t>info (for Sender Key): 0x8541014837cbf3210017a2d30a634b657910 (18 bytes)</t>  <t>info (for Recipient Key): 0x85404837cbf3210017a2d30a634b657910 (17 bytes)</t>  <t>info (for Common IV): 0x85404837cbf3210017a2d30a6249560d (16 bytes)</t></list></t><t>Outputs:</t><t><list style="symbols">  <t>Sender Key: 0xe39a0c7c77b43f03b4b39ab9a268699f (16 bytes)</t>  <t>Recipient Key: 0xaf2a1300a5e95788b356336eeecd2b92 (16 bytes)</t>  <t>Common IV: 0x2ca58fb85ff1b81c0b7181b85e (13 bytes)</t></list></t><t>From the previous parameters and a Partial IV equal to 0 (both for sender and recipient):</t><t><list style="symbols">  <t>sender nonce: 0x2da58fb85ff1b81d0b7181b85e (13 bytes)</t>  <t>recipient nonce: 0x2ca58fb85ff1b81c0b7181b85e (13 bytes)</t></list></t></section></section><section anchor="tv4" title="Test Vector 4: OSCORE Request, Client"><t>This section contains a test vector for an OSCORE-protected CoAPGET request using the security context derived in <xreftarget="key-der-tv-ms"/>. The unprotected request only contains theUri-Path and Uri-Host options.</t><t>Unprotected CoAP request: 0x44015d1f00003974396c6f63616c686f737483747631 (22 bytes)</t><t>Common Context:</t><t><list style="symbols">  <t>AEAD Algorithm: 10 (AES-CCM-16-64-128)</t>  <t>Key Derivation Function: HKDF SHA-256</t>  <t>Common IV: 0x4622d4dd6d944168eefb54987c (13 bytes)</t></list></t><t>Sender Context:</t><t><list style="symbols">  <t>Sender ID: 0x (0 byte)</t>  <t>Sender Key: 0xf0910ed7295e6ad4b54fc793154302ff (16 bytes)</t>  <t>Sender Sequence Number: 20</t></list></t><t>The following COSE and cryptographic parameters are derived:</t><t><list style="symbols">  <t>Partial IV: 0x14 (1 byte)</t>  <t>kid: 0x (0 byte)</t>  <t>external_aad: 0x8501810a40411440 (8 bytes)</t>  <t>AAD: 0x8368456e63727970743040488501810a40411440 (20 bytes)</t>  <t>plaintext: 0x01b3747631 (5 bytes)</t>  <t>encryption key: 0xf0910ed7295e6ad4b54fc793154302ff (16 bytes)</t>  <t>nonce: 0x4622d4dd6d944168eefb549868 (13 bytes)</t></list></t><t>From the previous parameter, the following is derived:</t><t><list style="symbols">  <t>OSCORE option value: 0x0914 (2 bytes)</t>  <t>ciphertext: 0x612f1092f1776f1c1668b3825e (13 bytes)</t></list></t><t>From there:</t><t><list style="symbols">  <t>Protected CoAP request (OSCORE message): 0x44025d1f00003974396c6f63616c686f7374620914ff612f1092f1776f1c1668b3825e (35 bytes)</t></list></t></section><section anchor="tv5" title="Test Vector 5: OSCORE Request, Client"><t>This section contains a test vector for an OSCORE-protected CoAP GET request using the security context derived in <xref target="key-der-tv"/>. The unprotected request only contains the Uri-Path and Uri-Host options.</t><t>Unprotected CoAP request: 0x440171c30000b932396c6f63616c686f737483747631 (22 bytes)</t><t>Common Context:</t><t><list style="symbols">  <t>AEAD Algorithm: 10 (AES-CCM-16-64-128)</t>  <t>Key Derivation Function: HKDF SHA-256</t>  <t>Common IV: 0xbe35ae297d2dace910c52e99f9 (13 bytes)</t></list></t><t>Sender Context:</t><t><list style="symbols">  <t>Sender ID: 0x00 (1 bytes)</t>  <t>Sender Key: 0x321b26943253c7ffb6003b0b64d74041 (16 bytes)</t>  <t>Sender Sequence Number: 20</t></list></t><t>The following COSE and cryptographic parameters are derived:</t><t><list style="symbols">  <t>Partial IV: 0x14 (1 byte)</t>  <t>kid: 0x00 (1 byte)</t>  <t>external_aad: 0x8501810a4100411440 (9 bytes)</t>  <t>AAD: 0x8368456e63727970743040498501810a4100411440 (21 bytes)</t>  <t>plaintext: 0x01b3747631 (5 bytes)</t>  <t>encryption key: 0x321b26943253c7ffb6003b0b64d74041 (16 bytes)</t>  <t>nonce: 0xbf35ae297d2dace910c52e99ed (13 bytes)</t></list></t><t>From the previous parameter, the following is derived:</t><t><list style="symbols">  <t>OSCORE option value: 0x091400 (3 bytes)</t>  <t>ciphertext: 0x4ed339a5a379b0b8bc731fffb0 (13 bytes)</t></list></t><t>From there:</t><t><list style="symbols">  <t>Protected CoAP request (OSCORE message): 0x440271c30000b932396c6f63616c686f737463091400ff4ed339a5a379b0b8bc731fffb0 (36 bytes)</t></list></t></section><section anchor="tv6" title="Test Vector 6: OSCORE Request, Client"><t>This section contains a test vector for an OSCORE-protected CoAP GET request for an application that sets the ID Context and requires it to be sent in the request, so 'kid context' is present in the protected message. This test vector uses the security context derived in <xref target="key-der-kc"/>. The unprotected request only contains the Uri-Path and Uri-Host options.</t><t>Unprotected CoAP request: 0x44012f8eef9bbf7a396c6f63616c686f737483747631 (22 bytes)</t><t>Common Context:</t><t><list style="symbols">  <t>AEAD Algorithm: 10 (AES-CCM-16-64-128)</t>  <t>Key Derivation Function: HKDF SHA-256</t>  <t>Common IV: 0x2ca58fb85ff1b81c0b7181b85e (13 bytes)</t>  <t>ID Context: 0x37cbf3210017a2d3 (8 bytes)</t></list></t><t>Sender Context:</t><t><list style="symbols">  <t>Sender ID: 0x (0 bytes)</t>  <t>Sender Key: 0xaf2a1300a5e95788b356336eeecd2b92 (16 bytes)</t>  <t>Sender Sequence Number: 20</t></list></t><t>The following COSE and cryptographic parameters are derived:</t><t><list style="symbols">  <t>Partial IV: 0x14 (1 byte)</t>  <t>kid: 0x (0 byte)</t>  <t>kid context: 0x37cbf3210017a2d3 (8 bytes)</t>  <t>external_aad: 0x8501810a40411440 (8 bytes)</t>  <t>AAD: 0x8368456e63727970743040488501810a40411440 (20 bytes)</t>  <t>plaintext: 0x01b3747631 (5 bytes)</t>  <t>encryption key: 0xaf2a1300a5e95788b356336eeecd2b92 (16 bytes)</t>  <t>nonce: 0x2ca58fb85ff1b81c0b7181b84a (13 bytes)</t></list></t><t>From the previous parameter, the following is derived:</t><t><list style="symbols">  <t>OSCORE option value: 0x19140837cbf3210017a2d3 (11 bytes)</t>  <t>ciphertext: 0x72cd7273fd331ac45cffbe55c3 (13 bytes)</t></list></t><t>From there:</t><t><list style="symbols">  <t>Protected CoAP request (OSCORE message): 0x44022f8eef9bbf7a396c6f63616c686f73746b19140837cbf3210017a2d3ff72cd7273fd331ac45cffbe55c3 (44 bytes)</t></list></t></section><section anchor="tv7" title="Test Vector 7: OSCORE Response, Server"><t>This section contains a test vector for an OSCORE-protected 2.05 (Content) response to the request in <xref target="tv4"/>. The unprotected response has payload "Hello World!" and no options. The protected response does not contain a 'kid' nor a Partial IV. Note that some parameters are derived from the request.</t><t>Unprotected CoAP response: 0x64455d1f00003974ff48656c6c6f20576f726c6421 (21 bytes)</t><t>Common Context:</t><t><list style="symbols">  <t>AEAD Algorithm: 10 (AES-CCM-16-64-128)</t>  <t>Key Derivation Function: HKDF SHA-256</t>  <t>Common IV: 0x4622d4dd6d944168eefb54987c (13 bytes)</t></list></t><t>Sender Context:</t><t><list style="symbols">  <t>Sender ID: 0x01 (1 byte)</t>  <t>Sender Key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)</t>  <t>Sender Sequence Number: 0</t></list></t><t>The following COSE and cryptographic parameters are derived:</t><t><list style="symbols">  <t>external_aad: 0x8501810a40411440 (8 bytes)</t>  <t>AAD: 0x8368456e63727970743040488501810a40411440 (20 bytes)</t>  <t>plaintext: 0x45ff48656c6c6f20576f726c6421 (14 bytes)</t>  <t>encryption key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)</t>  <t>nonce: 0x4622d4dd6d944168eefb549868 (13 bytes)</t></list></t><t>From the previous parameter, the following is derived:</t><t><list style="symbols">  <t>OSCORE option value: 0x (0 bytes)</t>  <t>ciphertext: 0xdbaad1e9a7e7b2a813d3c31524378303cdafae119106 (22 bytes)</t></list></t><t>From there:</t><t><list style="symbols">  <t>Protected CoAP response (OSCORE message): 0x64445d1f0000397490ffdbaad1e9a7e7b2a813d3c31524378303cdafae119106 (32 bytes)</t></list></t></section><section anchor="tv8" title="Test Vector 8: OSCORE Response with Partial IV, Server"><t>This section contains a test vector for an OSCORE protected 2.05 (Content) response to the request in <xref target="tv4"/>. The unprotected response has payload "Hello World!" and no options. The protected response does not contain a 'kid', but contains a  Partial IV. Note that some parameters are derived from the request.</t><t>Unprotected CoAP response: 0x64455d1f00003974ff48656c6c6f20576f726c6421 (21 bytes)</t><t>Common Context:</t><t><list style="symbols">  <t>AEAD Algorithm: 10 (AES-CCM-16-64-128)</t>  <t>Key Derivation Function: HKDF SHA-256</t>  <t>Common IV: 0x4622d4dd6d944168eefb54987c (13 bytes)</t></list></t><t>Sender Context:</t><t><list style="symbols">  <t>Sender ID: 0x01 (1 byte)</t>  <t>Sender Key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)</t>  <t>Sender Sequence Number: 0</t></list></t><t>The following COSE and cryptographic parameters are derived:</t><t><list style="symbols">  <t>Partial IV: 0x00 (1 byte)</t>  <t>external_aad: 0x8501810a40411440 (8 bytes)</t>  <t>AAD: 0x8368456e63727970743040488501810a40411440 (20 bytes)</t>  <t>plaintext: 0x45ff48656c6c6f20576f726c6421 (14 bytes)</t>  <t>encryption key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)</t>  <t>nonce: 0x4722d4dd6d944169eefb54987c (13 bytes)</t></list></t><t>From the previous parameter, the following is derived:</t><t><list style="symbols">  <t>OSCORE option value: 0x0100 (2 bytes)</t>  <t>ciphertext: 0x4d4c13669384b67354b2b6175ff4b8658c666a6cf88e (22 bytes)</t></list></t><t>From there:</t><t><list style="symbols">  <t>Protected CoAP response (OSCORE message): 0x64445d1f00003974920100ff4d4c13669384b67354b2b6175ff4b8658c666a6cf88e (34 bytes)</t></list></t></section></section><section anchor="overview-sec-properties" title="Overview of Security Properties"><section anchor="threat-model" title="Threat Model"><t>This section describes the threat model using the terms of <xref target="RFC3552"/>.</t><t>It is assumed that the endpoints running OSCORE have not themselvesbeen compromised. The attacker is assumed to have control of the CoAPchannel over which the endpoints communicate, including intermediarynodes. The attacker is capable of launching any passive or activeon-path or off-path attacks; including eavesdropping, trafficanalysis, spoofing, insertion, modification, deletion, delay, replay,man-in-the-middle, and denial-of-service attacks. This means that theattacker can read any CoAP message on the network and undetectablyremove, change, or inject forged messages onto the wire.</t><t>OSCORE targets the protection of the CoAP request/response layer (Section 2 of <xref target="RFC7252"/>) between the endpoints, including the CoAP Payload, Code, Uri-Path/Uri-Query, and the other Class E option instances (<xref target="coap-options"/>).</t><t>OSCORE does not protect the CoAP messaging layer (Section 2 of <xref target="RFC7252"/>) or other lower layers involved in routing and transporting the CoAP requests and responses.</t><t>Additionally, OSCORE does not protect Class U option instances(<xref target="coap-options"/>), as these are used to support CoAPforward proxy operations (see Section 5.7.2 of <xreftarget="RFC7252"/>). The supported proxies (forwarding,cross-protocol, e.g., CoAP to CoAP-mappable protocols such as HTTP)must be able to change certain Class U options (by instruction fromthe Client), resulting in the CoAP request being redirected to theserver. Changes caused by the proxy may result in the request notreaching the server or reaching the wrong server. For cross-protocolproxies, mappings are done on the Outer part of the message so theseprotocols are essentially used as transport. Manipulation of theseoptions may thus impact whether the protected message reaches or doesnot reach the destination endpoint.</t><t>Attacks on unprotected CoAP message fields generally causes denial-of-service attacks which are out of scope of this document, more details are given in <xref target="unprot-fields"/>.</t><t>Attacks against the CoAP request-response layer are in scope. OSCORE is intended to protect against eavesdropping, spoofing, insertion, modification, deletion, replay, and man-in-the middle attacks.</t><t>OSCORE is susceptible to traffic analysis as discussed later in <xref target="overview-sec-properties"/>.</t></section><section anchor="supp-proxy-op" title="Supporting Proxy Operations"><t>CoAP is designed to work with intermediaries reading and/orchanging CoAP message fields to perform supporting operations inconstrained environments, e.g., forwarding and cross-protocoltranslations.</t><t>Securing CoAP on the transport layer protects the entire messagebetween the endpoints, in which case CoAP proxy operations are notpossible. In order to enable proxy operations, security on the transportlayer needs to be terminated at the proxy; in which case, the CoAPmessage in its entirety is unprotected in the proxy.</t><t>Requirements for CoAP end-to-end security are specified in <xreftarget="CoAP-E2E-Sec"/>, in particular, forwarding is detailed inSection 2.2.1. The client and server are assumed to be honest, whileproxies and gateways are only trusted to perform their intendedoperations.</t><t>By working at the CoAP layer, OSCORE enables different CoAP messagefields to be protected differently, which allows message fieldsrequired for proxy operations to be available to the proxy whilemessage fields intended for the other endpoint remain protected. Inthe remainder of this section, we analyze how OSCORE protects theprotected message fields and the consequences of message fieldsintended for proxy operation being unprotected.</t></section><section anchor="prot-message-fields" title="Protected Message Fields"><t>Protected message fields are included in the plaintext (<xreftarget="plaintext"/>) and the AAD (<xreftarget="AAD"/>) of the COSE_Encrypt0 object and encrypted using anAEAD algorithm.</t><t>OSCORE depends on a preestablished random Master Secret (<xreftarget="master-secret"/>) used to derive encryption keys, and aconstruction for making (key, nonce) pairs unique (<xreftarget="kn-uniqueness"/>). Assuming this is true, and the keys areused for no more data than indicated in <xref target="max-seq"/>,OSCORE should provide the following guarantees:</t><t><list style="symbols">  <t>Confidentiality: An attacker should not be able to determine the plaintext contents of a given OSCORE message or determine that different plaintexts are related (<xref target="plaintext"/>).</t>  <t>Integrity: An attacker should not be able to craft a new OSCORE message with protected message fields different from an existing OSCORE message that will be accepted by the receiver.</t>  <t>Request-response binding: An attacker should not be able to make a client match a response to the wrong request.</t>  <t>Non-replayability: An attacker should not be able to cause the receiver to accept a message that it has previously received and accepted.</t></list></t><t>In the above, the attacker is anyone except the endpoints, e.g., a compromised intermediary. Informally, OSCORE provides these properties by AEAD-protecting the plaintext with a strong key and uniqueness of (key, nonce) pairs. AEAD encryption <xref target="RFC5116"/> provides confidentiality and integrity for the data. Response-request binding is provided by including the 'kid' and Partial IV of the request in the AAD of the response. Non-replayability of requests and notifications is provided by using unique (key, nonce) pairs and a replay protection mechanism (application dependent, see <xref target="replay-protection"/>).</t><t>OSCORE is susceptible to a variety of traffic analysis attacksbased on observing the length and timing of encrypted packets. OSCOREdoes not provide any specific defenses against this form of attack,but the application may use a padding mechanism to prevent an attackerfrom directly determine the length of the padding. However,information about padding may still be revealed by side-channelattacks observing differences in timing.</t></section><section anchor="kn-uniqueness" title="Uniqueness of (key, nonce)"><t>In this section, we show that (key, nonce) pairs are unique as long as the requirements in Sections <xref target="req-params" format="counter"/> and <xref target="max-seq" format="counter"/> are followed.</t><t>Fix a Common Context (<xref target="context-definition"/>) and an endpoint, called the encrypting endpoint. An endpoint may alternate between client and server roles, but each endpoint always encrypts with the Sender Key of its Sender Context. Sender Keys are (stochastically) unique since they are derived with HKDF using unique Sender IDs, so messages encrypted by different endpoints use different keys. It remains to be proven that the nonces used by the fixed endpoint are unique.</t><t>Since the Common IV is fixed, the nonces are determined by PIV, where PIV takes the value of the Partial IV of the request or of the response, and by the Sender ID of the endpoint generating that Partial IV (ID_PIV). The nonce construction (<xref target="nonce"/>) with the size of the ID_PIV (S) creates unique nonces for different (ID_PIV, PIV) pairs. There are two cases:</t><t>A. For requests, and responses with Partial IV (e.g., Observe notifications):</t><t><list style="symbols">  <t>ID_PIV = Sender ID of the encrypting endpoint</t>  <t>PIV = current Partial IV of the encrypting endpoint</t></list></t><t>Since the encrypting endpoint steps the Partial IV for each use, the nonces used in case A are all unique as long as the number of encrypted messages is kept within the required range (<xref target="max-seq"/>).</t><t>B. For responses without Partial IV (e.g., single response to a request):</t><t><list style="symbols">  <t>ID_PIV = Sender ID of the endpoint generating the request</t>  <t>PIV = Partial IV of the request</t></list></t><t>Since the Sender IDs are unique, ID_PIV is different from the Sender ID of the encrypting endpoint. Therefore, the nonces in case B are different compared to nonces in case A, where the encrypting endpoint generated the Partial IV. Since the Partial IV of the request is verified for replay (<xref target="replay-protection"/>) associated to this Recipient Context, PIV is unique for this ID_PIV, which makes all nonces in case B distinct.</t></section><section anchor="unprot-fields" title="Unprotected Message Fields"><t>This section analyzes attacks on message fields that are not protected by OSCORE according to the threat model <xref target="threat-model"/>.</t><section anchor="sec-coap-headers" title="CoAP Header Fields"><t><list style="symbols">  <t>Version. The CoAP version <xref target="RFC7252"/> is not expected to be sensitive to disclosure. Currently, there is only one CoAP version defined. A change of this parameter is potentially a denial-of-service attack. Future versions of CoAP need to analyze attacks to OSCORE-protected messages due to an adversary changing the CoAP version.</t>  <t>Token/Token Length. The Token field is a client-local identifier  for differentiating between concurrent requests <xref  target="RFC7252"/>. CoAP proxies are allowed to read and change  Token and Token Length between hops. An eavesdropper reading the  Token can match requests to responses that can be used in traffic  analysis. In particular, this is true for notifications, where  multiple responses are matched with one request. Modifications of  Token and Token Length by an on-path attacker may become a  denial-of-service attack, since it may prevent the client to  identify to which request the response belongs or to find the  correct information to verify integrity of the response.</t>    <t>Code. The Outer CoAP Code of an OSCORE message is POST or FETCH  for requests with corresponding response codes. An endpoint  receiving the message discards the Outer CoAP Code and uses the  Inner CoAP Code instead (see <xref target="coap-header"/>). Hence,  modifications from attackers to the Outer Code do not impact the  receiving endpoint. However, changing the Outer Code from FETCH to a  Code value for a method that does not work with Observe (such as  POST) may, depending on proxy implementation since Observe is  undefined for several Codes, cause the proxy to not forward  notifications, which is a denial-of-service attack. The use of FETCH  rather than POST reveals no more than what is revealed by the  presence of the Outer Observe option.</t>  <t>Type/Message ID. The Type/Message ID fields <xref target="RFC7252"/> reveal information about the UDP transport binding, e.g., an eavesdropper reading the Type or Message ID gain information about how UDP messages are related to each other. CoAP proxies are allowed to change Type and Message ID. These message fields are not present in CoAP over TCP <xref target="RFC8323"/> and does not impact the request/response message. A change of these fields in a UDP hop is a denial-of-service attack. By sending an ACK, an attacker can make the endpoint believe that it does not need to retransmit the previous message. By sending a RST, an attacker may be able to cancel an observation. By changing a NON to a CON, the attacker can cause the receiving endpoint to ACK messages for which no ACK was requested.</t>  <t>Length. This field contain the length of the message <xref target="RFC8323"/>, which may be used for traffic analysis. These message fields are not present in CoAP over UDP and do not impact the request/response message. A change of Length is a denial-of-service attack similar to changing TCP header fields.</t></list></t></section><section anchor="sec-coap-options" title="CoAP Options"><t><list style="symbols">  <t>Max-Age. The Outer Max-Age is set to zero to avoid unnecessary caching of OSCORE error responses. Changing this value thus may cause unnecessary caching. No additional information is carried with this option.</t>  <t>Proxy-Uri/Proxy-Scheme. These options are used in CoAP forward proxy deployments. With OSCORE, the Proxy-Uri option does not contain the Uri-Path/Uri-Query parts of the URI. The other parts of Proxy-Uri cannot be protected because forward proxies need to change them in order to perform their functions. The server can verify what scheme is used in the last hop, but not what was requested by the client or what was used in previous hops.</t>  <t>Uri-Host/Uri-Port. In forward proxy deployments, the Uri-Host/Uri-Port may be changed by an adversary, and the application needs to handle the consequences of that (see <xref target="uri-host"/>).<!--[rfced] Please clarify this sentence.  The use of "either" calls for two (or more) symmetrcial alternatives.  Also, are all things in thesentence discouraged or simply reveal privacy-sensitive information?Note that our suggested text below may still need updates based on youranswer to the last question.Original:    The Uri-Host may either be omitted, reveal information equivalent to    that of the IP address or more privacy-sensitive information,    which is discouraged.Perhaps:    The Uri-Host may either be omitted, reveal information equivalent to    that of the IP address, or reveal more privacy-sensitive information,    which is discouraged.[Auth] To answer your question: only the "reveal more privacy-sensitive information" is discouraged. The proposal sounds good, we went ahead andreplaced in the text below.-->  The Uri-Host may either be omitted, reveal information equivalent to that of the IP address, or reveal more privacy-sensitive information, which is discouraged.</t>  <t>Observe. The Outer Observe option is intended for a proxy to  support forwarding of Observe messages, but it is ignored by the  endpoints since the Inner Observe option determines the processing in the  endpoints. Since the Partial IV provides absolute ordering of  notifications, it is not possible for an intermediary to spoof  reordering (see <xref target="observe"/>). The absence of Partial  IV, since only allowed for the first notification, does not prevent  correct ordering of notifications. The size and distributions of  notifications over time may reveal information about the content or  nature of the notifications.<!--[rfced] What does not "open up for attacks"? In other words,please clarify what "that" refers to.Original:      Cancellations (Section 4.1.3.5.1)      are not bound to the corresponding registrations in the same way      responses are bound to requests in OSCORE (see Appendix D.3), but      that does not open up for attacks based on mismatched      cancellations, since for cancellations to be accepted, all options      in the decrypted message except for ETag Options MUST be the same      (see Section 4.1.3.5).[Auth] "that" refers to "Cancellations are not bound to the corresponding registration" (the whole sentence).-->  Cancellations (<xref  target="observe-registration"/>) are not bound to the corresponding  registrations in the same way responses are bound to requests in  OSCORE (see <xref target="prot-message-fields"/>), but that does not  open up for attacks based on mismatched cancellations, since for  cancellations to be accepted, all options in the decrypted message  except for ETag Options MUST be the same (see <xref  target="observe"/>).</t>    <t>Block1/Block2/Size1/Size2. The Outer Block options enable  fragmentation of OSCORE messages in addition to segmentation  performed by the Inner Block options. The presence of these options  indicates a large message being sent, and the message size can be  estimated and used for traffic analysis. Manipulating these options  is a potential denial-of-service attack, e.g., injection of alleged  Block fragments. The specification of a maximum size of message,  MAX_UNFRAGMENTED_SIZE (<xref target="outer-block-options"/>), above  which messages will be dropped, is intended as one measure to  mitigate this kind of attack.</t>    <t>No-Response. The Outer No-Response option is used to support  proxy functionality, specifically to avoid error transmissions from  proxies to clients, and to avoid bandwidth reduction to servers by  proxies applying congestion control when not receiving  responses. Modifying or introducing this option is a potential  denial-of-service attack against the proxy operations, but since the  option has an Inner value, its use can be securely agreed upon between the  endpoints. The presence of this option is not expected to reveal any  sensitive information about the message exchange.</t>    <t>OSCORE. The OSCORE option contains information about the  compressed COSE header. Changing this field may cause OSCORE  verification to fail.</t></list></t></section><section anchor="error-and-signaling-messages" title="Error and Signaling Messages"><t>Error messages occurring during CoAP processing are protected end-to-end. Error messages occurring during OSCORE processing are not always possible to protect, e.g., if the receiving endpoint cannot locate the right security context. For this setting, unprotected error messages are allowed as specified to prevent extensive retransmissions. Those error messages can be spoofed or manipulated, which is a potential denial-of-service attack.</t><t>This document specifies OPTIONAL error codes and specific diagnostic payloads for OSCORE processing error messages. Such messages might reveal information about how many and which security contexts exist on the server. Servers MAY want to omit the diagnostic payload of error messages, use the same error code for all errors, or avoid responding altogether in case of OSCORE processing errors, if that is a security concern for the application. Moreover, clients MUST NOT rely on the error code or the diagnostic payload to trigger specific actions, as these errors are unprotected and can be spoofed or manipulated.</t><t>Signaling messages used in CoAP over TCP <xref target="RFC8323"/> are intended to be hop-by-hop; spoofing signaling messages can be used as a denial-of-service attack of a TCP connection.</t></section><section anchor="http-message-fields" title="HTTP Message Fields"><t>In contrast to CoAP, where OSCORE does not protect header fields to enable CoAP-CoAP proxy operations, the use of OSCORE with HTTP is restricted to transporting a protected CoAP message over an HTTP hop. Any unprotected HTTP message fields may reveal information about the transport of the OSCORE message and enable various denial-of-service attacks.It is RECOMMENDED to additionally use TLS <xref target="RFC8446"/> for HTTP hops, which enables encryption and integrity protection of headers, but still leaves some information for traffic analysis.</t></section></section></section><section anchor="cddl-sum" title="CDDL Summary"><!-- [rfced] Please consider rephrasing the text regarding draft-ietf-cbor-cddl-08 [CDDL] to be more concise. Also, we note that document is in the RFC Editor's queue, so this text mightrequire further updates.Original:   Data structure definitions in the present specification employ the   CDDL language for conciseness and precision.  CDDL is defined in   [I-D.ietf-cbor-cddl], which at the time of writing this appendix is   in the process of completion.  As the document is not yet available   for a normative reference, the present appendix defines the small   subset of CDDL that is being used in the present specification.Perhaps:   Data structure definitions in the present specification employ the   CDDL language for conciseness and precision.  CDDL is defined in   [CDDL], which has not yet been published as an RFC.  Therefore,    this appendix defines the small subset of CDDL that is used in the    present specification.[Auth] We think the proposal is good. Morever, CDDL (RFC-to-be 8610)is almost published, with the document approved already, so we think that, as soon as that is done, the second sentence should be removed. In the meantime, we have replaced the original with the proposal.--><t>Data structure definitions in the present specification employ theCDDL language for conciseness and precision.  CDDL is defined in<xref target="CDDL"/>, which has not yet been published as an RFC.  Therefore, this appendix defines the small subset of CDDL that is used in the present specification.</t><t>Within the subset being used here, a CDDL rule is of the form <spanx style="verb">name =type</spanx>, where <spanx style="verb">name</spanx> is the name given to the <spanx style="verb">type</spanx>.A <spanx style="verb">type</spanx> can be one of:</t><t><list style="symbols">  <t>a reference to another named type, by giving its name.  Thepredefined named types used in the present specification are as follows:<spanx style="verb">uint</spanx>, an unsigned integer (as represented in CBOR by major type 0);<spanx style="verb">int</spanx>, an unsigned or negative integer (as represented in CBOR by majortype 0 or 1);<spanx style="verb">bstr</spanx>, a byte string (as represented in CBOR by major type 2);<spanx style="verb">tstr</spanx>, a text string (as represented in CBOR by major type 3);</t>  <t>a choice between two types, by giving both types separated by a <spanx style="verb">/</spanx>;</t>  <t>an array type (as represented in CBOR by major type 4), where thesequence of elements of the array is described by giving a sequenceof entries separated by commas <spanx style="verb">,</spanx>, and this sequence is enclosed bysquare brackets <spanx style="verb">[</spanx> and <spanx style="verb">]</spanx>.Arrays described by an array description contain elements thatcorrespond one-to-one to the sequence of entries given.Each entry of an array description is of the form <spanx style="verb">name : type</spanx>, where<spanx style="verb">name</spanx> is the name given to the entry and <spanx style="verb">type</spanx> is the type of thearray element corresponding to this entry.</t></list></t></section><section numbered="no" anchor="acknowledgments" title="Acknowledgments"><t>The following individuals provided input to this document: Christian Amsuess, Tobias Andersson, Carsten Bormann, Joakim Brorsson, Ben Campbell, Esko Dijk, Jaro Fietz, Thomas Fossati, Martin Gunnarsson, Klaus Hartke, Mirja Kuehlewind, Kathleen Moriarty, Eric Rescorla, Michael Richardson, Adam Roach, Jim Schaad, Peter van der Stok, Dave Thaler, Martin Thomson, Marco Tiloca, William Vignat, and Malisa Vucinic.</t><t>Ludwig Seitz and Goeran Selander worked on this document as part of the CelticPlus project CyberWI, with funding from Vinnova. Ludwig Seitz had additional funding from the SSF project SEC4Factory under the grant RIT17-0032.</t></section><!-- [rfced] The following questions apply to the entire text.a) The following terminology appears to be used inconsistently with regard tocapitalization/hyphenation/etc. Please review these occurrences and let usknow if/how they may be made consistent.Sender Sequence Number vs. sender sequence numberReplay Window vs. replay windowClass E vs. class E (as relates to any letter)Outer vs. outer (and Inner vs. inner)Ciphertext vs. ciphertext (and Plaintext vs. plaintext)Header Field vs. header fieldObject vs. objectRequest/Response vs. request/response (please also review the terms   it modifies)[Auth] The following should be used:* Sender Sequence Number (we replaced 4 instances of sender sequence number);* Replay Window (replaced 4 instances). Note that the 2 remaining instances should not be replaced as they refer to the general concept of replay window, rather than to the security context element;* Class E (replaced 7 instances)* Outer (replaced 1 instances). Note that other instances of "outer" and "inner" are in xref;* ciphertext (1 instance) and plaintext (1 instance). Note that other instances of "Plaintext" appearon section headers, figure captions, reference title and should not be replaced.* header field. We replaced 5 instances of "Header" (also when not used next fo "field"), and kept the other 15 as they are either section headers, figures, figure captions, or refer to the "OSCORE Header Compression" mechanism.* object (replaced 7 instances). The rest of the instances should be for Object Security or CBOR Object Signing and Encryption.* request (replaced 5 instances) and response (replaced 4 instances). The rest are section headers,figures, beginning of sentence, or part of a word that is capitalized ("Request-Tag", "No-Response")Additionally, we replaced the following, also for consistency:* Layer replaced by layer (5 instances), and Messaging by messaging (3 instances), consistent with RFC7252* AEAD algorithm replaced AEAD Algorithm (1 instance) because it referred to the actual field in the security context. Note that AEAD algorithm is used throughout the text as well.* messaging layer replaced by CoAP messaging layer (1 instance, to align with rest of the document)* request/response Codes replaced by CoAP request/response Codes (1 instance)b) Should error codes and values be handled more similarly?For example, we see:Original:   The client MAY set the Outer No-Response value to 26   ('suppress all known codes') ...vs.Original:   The client MUST be prepared to receive and discard 5.04    (Gateway Timeout)...May we update the former to remove the quotes and capitalize the name?[Auth] About capitalization: no, since "suppress all known codes" is not standardized in the same way "Gateway Timeout" is. "Gateway Timeout" is registered in IANA (https://www.iana.org/assignments/core-parameters/core-parameters.xhtml#response-codes)and is the official terminology. "suppress all known codes" is our shortcut to describevalue 26 which is detailed in https://tools.ietf.org/html/rfc7967#section-2.1 .We do think that removing single quotes is a good suggestion, so we did that.b1) Additionally, please review if "error message" or the like should beadded to instances mentioning an error code for consistent usagethroughout.b2) Should cases like "reply with 307 or 308" be updated to include the names?[Auth] Yes. We replaced the following:OLD:   Since OSCORE requires the HTTP body to be preserved across redirects,   the HTTP server is RECOMMENDED to reply with 307 or 308 instead of   301 or 302.NEW:   Since OSCORE requires the HTTP body to be preserved across redirects,   the HTTP server is RECOMMENDED to reply with 307 (Temporary Redirect)   or 308 (Permanent Redirect) instead of 301 (Moved Permanently) or 302   (Found).c) We see parameter names sometimes in single quotes and sometimes without(e.g., 'kid' vs. kid).  Please review these instances and let us knowwhat (if any) updates are necessary in either Old/New format or as aglobal replace.[Auth] We reviewed the instances, and we find it consistent with one exception.The "rule" we followed are:* quotes are not used in figures and examples (not to make it too heavy to read)* quotes are used everywhere elseThey apply to both 'kid' and 'kid context'.We replaced the leftover inconsistency:OLD   It is set to 1 if the kid is present in the compressed COSE object.NEW   It is set to 1 if 'kid' is present in the compressed COSE object. At the same time we noted a typo with quotes, and replaced:OLD   It is set to 1 if the compressed COSE object contains a 'kid contextNEW   It is set to 1 if the compressed COSE object contains a 'kid context'd) May we make cases like the following consistent?  If so, which form is preferred?...contain the string "Security context not found".vs....contain the contain the "Decryption failed" string.[Auth] Yes. We went with the first, and made the following changes:OLD   The   diagnostic payload MAY contain the "Replay detected" string.NEW   The   diagnostic payload MAY contain the string "Replay detected".OLD   The diagnostic payload MAY contain the   "Decryption failed" string.NEW   The diagnostic payload MAY contain the   string "Decryption failed".e) Please clarify the meaning of "Observe" when it's not followed by any wordsuch as "option" or "request". Does it always mean "the Observe option"? If so, should there be a statement that "Observe" is shorthand for "Observeoption" or will it be clear to the reader?  For example:Original:   Since POST with Observe is not defined, for messages with Observe, the   Outer Code ...Perhaps:   Since POST with the Observe option is not defined, for messages with the   Observe option, the Outer Code ...[Auth] We went ahead and checked the 78 instances of "Observe". "Observe" can refer to:* "Observe registration/cancellation/notifications", which are request messages containing the Observe option with a specific value, as defined in RFC7641;* Observe processing, i.e. the process of using/setting the Observe option: for exampleOriginal:   Observe [RFC7641] is an optional feature.  An implementation MAY   support CoAP [RFC7252] and the OSCORE option without supporting   [RFC7641], in which case the Observe-related processing can be   omitted.* Observe option* Observe messages/requests/responses, i.e. messages/requests/responses containing the Observe optionWe added the term option when "Observe" was implicitly referring to "Observe option".We did not replaced "Observe messages" with "messages containing the Observe option"if the readability of the text would have suffered from it. For example:Original:   If the client receives a response to an Observe request without an   Inner Observe option, then it verifies the response as a non-Observe   response, as specified in Section 8.4.Note that we also catched an inconsistency of capitalization:OLD   observe notificationNEW   Observe notification-->  </back></rfc>